<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go codelab step-by-step page</title>
    <link>https://mingrammer.com/go-codelab/index.xml</link>
    <description>Recent content on Go codelab step-by-step page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Nov 2016 10:20:44 +0900</lastBuildDate>
    <atom:link href="https://mingrammer.com/go-codelab/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>코드랩 소개</title>
      <link>https://mingrammer.com/go-codelab/codelab-introduction</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/codelab-introduction</guid>
      <description>

&lt;p&gt;본 코드랩은 &lt;strong&gt;GDG Devfest Incheon 2016&lt;/strong&gt;의 &lt;strong&gt;Go 언어를 활용한 코드랩&lt;/strong&gt;을 위해 제작되었습니다.&lt;/p&gt;

&lt;p&gt;이 코드랩의 단계를 차근차근 밟아나가게 되면, 마지막에 여러분은 Go 언어의 다음과 같은 특징들을 배울 수 있을겁니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go 애플리케이션과 패키지 구조&lt;/li&gt;
&lt;li&gt;Go 인터페이스와 구조체&lt;/li&gt;
&lt;li&gt;Go에서의 동시성 모델과 채널&lt;/li&gt;
&lt;li&gt;Go에서의 에러 핸들링&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 코드랩 튜토리얼에선 센서 데이터를 생성하는 클라이언트와 클라이언트로부터 받은 데이터를 로깅 하는 서버로 이루어진 간단한 IoT 애플리케이션을 구현할 것입니다.&lt;/p&gt;

&lt;p&gt;목차는 다음과 같습니다.&lt;/p&gt;

&lt;h4 id=&#34;1-설치-및-환경설정-install-and-env&#34;&gt;1. &lt;a href=&#34;https://mingrammer.com/go-codelab/install-and-env&#34;&gt;설치 및 환경설정&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;2-튜토리얼-구조-project-structure&#34;&gt;2. &lt;a href=&#34;https://mingrammer.com/go-codelab/project-structure&#34;&gt;튜토리얼 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;3-패키지와-임포트-package-and-import&#34;&gt;3. &lt;a href=&#34;https://mingrammer.com/go-codelab/package-and-import&#34;&gt;패키지와 임포트&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;4-구조체와-인터페이스-struct-and-interface&#34;&gt;4. &lt;a href=&#34;https://mingrammer.com/go-codelab/struct-and-interface&#34;&gt;구조체와 인터페이스&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;5-클라이언트-구조-client-structure&#34;&gt;5. &lt;a href=&#34;https://mingrammer.com/go-codelab/client-structure&#34;&gt;클라이언트 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;6-고루틴과-채널-goroutine-and-channel&#34;&gt;6. &lt;a href=&#34;https://mingrammer.com/go-codelab/goroutine-and-channel&#34;&gt;고루틴과 채널&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;7-서버-구조-및-net-http-server-structure-and-net-http&#34;&gt;7. &lt;a href=&#34;https://mingrammer.com/go-codelab/server-structure-and-net-http&#34;&gt;서버 구조 및 net/http&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;8-서버에서-채널-동작-방식-및-로그-핸들러-how-server-and-logger-works&#34;&gt;8. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-server-and-logger-works&#34;&gt;서버에서 채널 동작 방식 및 로그 핸들러&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;9-에러-핸들링-error-handling-in-go&#34;&gt;9. &lt;a href=&#34;https://mingrammer.com/go-codelab/error-handling-in-go&#34;&gt;에러 핸들링&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;10-애플리케이션-동작-방식-how-application-works&#34;&gt;10. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-application-works&#34;&gt;애플리케이션 동작 방식&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;11-축하합니다-next-to-go&#34;&gt;11. &lt;a href=&#34;https://mingrammer.com/go-codelab/next-to-go&#34;&gt;축하합니다!&lt;/a&gt;&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>설치 및 환경셋팅</title>
      <link>https://mingrammer.com/go-codelab/install-and-env</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/install-and-env</guid>
      <description>

&lt;h3 id=&#34;이모-여기-순대국-sdk-하나요&#34;&gt;이모! 여기 순대국(SDK) 하나요!&lt;/h3&gt;

&lt;p&gt;어떤 언어를 쓰던 간에 해당 언어에 대한 SDK가 필요하겠죠. 그리고 해당 언어를 잘 쓰기 위해 환경설정이 필요하고요. 이번 장에선 설치와 환경설정 하는 방법을 설명하려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;sdk-설치&#34;&gt;SDK 설치&lt;/h3&gt;

&lt;p&gt;공식 홈페이지 &lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt;에서 인스톨러를 다운로드받아 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;OS X/Linux&lt;/code&gt;에선 패키지 매니저로도 설치할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;// OS X
brew install go

// Ubuntu
sudo apt install golang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료되면 터미널(혹은 명령 프롬프트)에서 &lt;code&gt;go&lt;/code&gt;를 입력하여 결과를 확인합니다. 다음과 같은 결과가 나오면 기본 설치는 잘 된 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lkaybob@lkaybob-530u4c:/$ go
Go is a tool for managing Go source code.

Usage:

	go command [arguments]
...	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;환경변수-gopath-설정&#34;&gt;환경변수(GOPATH) 설정&lt;/h3&gt;

&lt;p&gt;Go언어에서는 Workspace라는 개념이 있습니다. 쉽게 말하자면, 여러분이 Go언어만을 사용해서 개발할 수 있는 공간입니다. 이 Workspace를 구성하면, Go언어로 개발하면서 사용하게 될 패키지들을 한 곳에서 관리할 수 있는 장점이 존재합니다. 이 Workspace는 예시로 다음과 같은 구조로 구성되어 있습니다. (Go언어 공식 홈페이지의 예시입니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$GOPATH/
        bin/
                hello
                outyet                      
        pkg/
                linux_amd64/
                        github.com/golang/example/
                                stringutil.a
        src/
                github.com/golang/example/
                        .git/   
                        hello/
                	           hello.go 
                        outyet/
                	           main.go  
                	           main_test.go
                golang.org/x/image/
                        .git/   
                ... (many more repositories and packages omitted) ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GOPATH&lt;/strong&gt; : Workspace 루트 디렉토리를 의미합니다. Go의 커맨드라인 명령어들은 이 디렉토리를 기준으로 동작합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;src&lt;/strong&gt; : Go 소스 파일들이 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pkg&lt;/strong&gt; : 패키지 오브젝트들이 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bin&lt;/strong&gt; : 실행 가능한 커맨드들이 위치합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 Workspace를 Go 프로젝트 디렉토리로 사용하기 위해서는 &lt;strong&gt;GOPATH&lt;/strong&gt;라는 환경변수로 등록해야합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;windows&#34;&gt;Windows&lt;/h4&gt;

&lt;p&gt;&amp;lsquo;내 컴퓨터&amp;rsquo; 아이콘을 우클릭해서 속성으로 들어가면 &amp;lsquo;시스템 속성&amp;rsquo; 창이 뜹니다. 이 창의 좌측 목록을 보면 &amp;lsquo;고급 시스템 설정&amp;rsquo;이라는 항목을 누르면 또 다른 창이 뜹니다. 이 창의 아래쪽을 보면 &amp;lsquo;환경변수&amp;rsquo;로 들어갑니다.&lt;/p&gt;

&lt;p&gt;여기서 조심해야할 것은 환경변수를 잘못 건드리면 Windows를 정상적으로 사용 못할 수 있으니 조심하셔야합니다. 여기서 우리는 환경변수를 새로 만들 것이기 때문에 &amp;lsquo;새로 만들기&amp;rsquo;를 클릭합니다. (위와 아래 목록 중 아래 목록에 하는 것을 추천합니다.) 변수 이름은 &lt;code&gt;GOPATH&lt;/code&gt;로 지정하고, 값은 여러분이 지정할 Workspace의 위치를 입력합니다. 만약 바탕화면에서 &lt;code&gt;GoDev&lt;/code&gt;라는 폴더를 만들었으면 다음과 같은 경로를 입력해주면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt; : Workspace로 지정할 폴더를 탐색기에서 열고, 주소창의 경로를 복사 붙여넣기하면 쉽게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;os-x-linux&#34;&gt;OS X/Linux&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt; 명령어를 통해 설정할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /path/to     &lt;span class=&#34;c1&#34;&gt;# 원하는 위치로 이동합니다.&lt;/span&gt;
mkdir work     &lt;span class=&#34;c1&#34;&gt;# 원하는 위치에 Workspace 디렉토리를 만듭니다.&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GOPATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/path/to/work      &lt;span class=&#34;c1&#34;&gt;# 해당 디렉토리를 GOPATH로 설정합니다.&lt;/span&gt;
mkdir work/src      &lt;span class=&#34;c1&#34;&gt;# 소스 파일 디렉토리를 생성합니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;또한 &lt;code&gt;.profile&lt;/code&gt;, &lt;code&gt;.bash_profile&lt;/code&gt;, &lt;code&gt;.zsh_profile&lt;/code&gt;에 경로를 등록할 수도 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;// .profile 
// .bash_profile
// .zsh_profile
// 여러분이 사용하는 쉘에 따라 설정하시면 됩니다.
...

&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GOPATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/path/to/work

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;프로젝트-다운받기&#34;&gt;프로젝트 다운받기&lt;/h3&gt;

&lt;p&gt;이제 설정한 Go언어의 Workspace에 프로젝트를 다운받아보겠습니다. 우리의 프로젝트는 다음의 GitHub Repository에 저장되어있습니다. Git이 설정되어 있는 경우엔, Go언어의 Workspace에서 다음의 명령어를 순차적으로 입력해주면 됩니다. 폴더를 만들어주는 것은 Go언어의 Workspace 형식에 맞추기 위함입니다. (이에 대한 자세한 내용은 &lt;a href=&#34;https://mingrammer.com/go-codelab/package-and-import&#34;&gt;패키지와 임포트&lt;/a&gt; 단계에서 확인하실 수 있습니다!)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir src
cd src

mkdir github.com
cd github.com

mkdir mingrammer
cd mingrammer

git clone git@github.com:mingrammer/go-codelab.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;명령어를 입력하고 기다려주면, Workspace 안에 &lt;code&gt;go-codelab&lt;/code&gt;이라는 폴더가 만들어지고 우리의 튜토리얼에 쓰일 코드가 안에 들어있을겁니다!&lt;/p&gt;

&lt;p&gt;다음 페이지에선 우리의 튜토리얼이 어떻게 구성되어있는지 확인해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt; : Go 언어 프로젝트를 가져오는 다른 방법으로는 &lt;a href=&#34;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&#34;&gt;go get&lt;/a&gt;이라는 명령어를 사용하는 것이 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>튜토리얼 구조</title>
      <link>https://mingrammer.com/go-codelab/project-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/project-structure</guid>
      <description>&lt;p&gt;이 튜토리얼은 크게 3부분(Client, Server, Log Handler)으로 나뉩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mingrammer.com/go-codelab/img/project_structure.png&#34; alt=&#34;Alt project_structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;기본적인 플로우는 위와 같으며 클라이언트에서 센서들이 데이터를 생성하면 이를 서버로 전송하고 서버는 이 데이터를 로깅하여 저장합니다.&lt;/p&gt;

&lt;p&gt;위에서 보이는 &lt;code&gt;Sensor&lt;/code&gt;는 우리가 구현할 가상의 센서로 아래의 3가지 센서들이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;자이로 센서 (Gyroscope Sensor)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;가속도 센서 (Accelometer Sensor)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;온도 및 습도계 (Temperature Sensor)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이들 센서의 종류는 잠시 후 설명할 &lt;code&gt;models&lt;/code&gt; 패키지에 정의되어 있으며, 센서들은 일정 시간 간격마다 &lt;code&gt;Server&lt;/code&gt;에게 &lt;code&gt;Sensor&lt;/code&gt;에서 발생한 측정값을 보내줍니다. 이 측정값으로는 각속도(Angle Velocity), 선속도(Gravitational Velocity), 온도 및 습도(Temperature and Humidity)가 있습니다.&lt;/p&gt;

&lt;p&gt;그러나, 우리는 가상의 센서를 구현하는 것이기 때문에, 실제 측정값을 넣지 못하므로 &lt;code&gt;faker&lt;/code&gt;라는 랜덤 생성기를 사용하여, 랜덤값을 서버에 보내줄 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;는 각 &lt;code&gt;Sensor&lt;/code&gt;에서 발생한 값을 HTTP를 통해 전달 받습니다. 이 때, 각 센서는 서로 다른 서버 포트 번호로 데이터를 전송하며 &lt;code&gt;Server&lt;/code&gt;는 받은 데이터를 통해 센서의 종류를 판별하고 값들을 로깅합니다.&lt;/p&gt;

&lt;p&gt;로깅할 데이터는 &lt;code&gt;Log Handler&lt;/code&gt;에게 넘겨지며, 이를 받은 &lt;code&gt;Log Handler&lt;/code&gt;는 실시간으로 각 &lt;code&gt;Sensor&lt;/code&gt;가 받은 센서값을 &lt;code&gt;log&lt;/code&gt; 폴더의 센서별 파일에 로그 형식으로 남깁니다.&lt;/p&gt;

&lt;p&gt;전체 튜토리얼의 구조는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go-codelab/
        faker/
                range.go
        models/
                sensor.go
        sensor_client.go
        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>패키지와 임포트</title>
      <link>https://mingrammer.com/go-codelab/package-and-import</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/package-and-import</guid>
      <description>

&lt;p&gt;이전에도 살펴봤듯이 이 튜토리얼은 다음과 같이 구성되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go-codelab/
        faker/
                range.go
        models/
                sensor.go
        sensor_client.go
        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go-codelab&lt;/code&gt;은 튜토리얼 프로젝트의 루트 디렉토리이며 모든 소스코드는 이 안에 위치합니다. &lt;code&gt;go-codelab&lt;/code&gt; 하위에는 &lt;code&gt;faker&lt;/code&gt; 디렉토리와 &lt;code&gt;models&lt;/code&gt; 디렉토리가 존재하며 &lt;code&gt;sensor_client.go&lt;/code&gt;와 &lt;code&gt;sensor_server.go&lt;/code&gt;가 단일 파일로 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;패키지&#34;&gt;패키지&lt;/h3&gt;

&lt;p&gt;Go 프로그램은 &lt;strong&gt;패키지&lt;/strong&gt;라고 하는 일련의 파일 그룹에 의해 관리됩니다. 패키지는 재사용이 가능하며 작은 단위의 &lt;code&gt;.go&lt;/code&gt; 확장자를 갖는 프로그램들로 구성됩니다. 이 튜토리얼엔 2개의 패키지가 존재합니다. 물론 정확히 말하자면 메인 패키지를 포함하여 총 3개의 패키지가 존재하지만 메인 패키지는 조금 특별하게 다뤄지므로 패키지라고 하면 메인 패키지를 제외한 일반적인 패키지를 말합니다. 이 튜토리얼엔 2개의 패키지가 존재하는데 바로 &lt;code&gt;faker&lt;/code&gt;와 &lt;code&gt;models&lt;/code&gt; 패키지입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;faker/
        range.go
models/
        sensor.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리가 다룰 패키지는 비록 단일 파일만 갖고 있지만 일반적인 경우엔 한 패키지에 작은 단위로 나뉜 여러 파일과 디렉토리가 존재합니다. 쉬운 예로 나중에 살펴보게될 &lt;code&gt;net/http&lt;/code&gt; 패키지의 경우 다음과 같이 구성되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net/http/
        cgi/
        cookiejar/
                testdata/
        fcgi/
        httptest/
        httputil/
        pprof/
        testdata/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 이제 우리 튜토리얼의 패키지들을 살펴봅시다. &lt;code&gt;faker&lt;/code&gt;의 &lt;code&gt;range.go&lt;/code&gt; 파일과 &lt;code&gt;models&lt;/code&gt;의 &lt;code&gt;sensor.go&lt;/code&gt;를 보면 상단에 다음과 같은 코드를 볼 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// faker/range.go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;math/rand&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// models/sensor.go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;strings&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;

	&lt;span class=&#34;s&#34;&gt;&amp;quot;github.com/mingrammer/go-codelab/faker&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;최상단을 보면 &lt;code&gt;package &amp;lt;name&amp;gt;&lt;/code&gt;형태의 코드를 볼 수 있습니다. 한 패키지에 속한 모든 Go 파일들은 이렇게 최상단에 자신이 속한 패키지명을 선언해야 합니다. 이 패키지명은 보통 패키지가 속한 디렉토리명을 따릅니다. 따라서, &lt;code&gt;range.go&lt;/code&gt;나 &lt;code&gt;sensor.go&lt;/code&gt;를 보면 각 파일이 &lt;code&gt;faker&lt;/code&gt;와 &lt;code&gt;models&lt;/code&gt; 패키지에 속한다는걸 바로 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;임포트&#34;&gt;임포트&lt;/h3&gt;

&lt;p&gt;위의 &lt;code&gt;range.go&lt;/code&gt;와 &lt;code&gt;sensor.go&lt;/code&gt; 파일을 보면 &lt;code&gt;package&lt;/code&gt; 아래에서 &lt;code&gt;import&lt;/code&gt;문을 볼 수 있습니다.  &lt;code&gt;import&lt;/code&gt;문을 통해 표준 또는 외부 패키지를 불러와 사용할 수 있습니다. 위 코드에서 보이는 &lt;code&gt;math/rand&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;fmt&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;는 Go의 표준 라이브러리 패키지입니다. 표준 라이브러리 패키지의 경우 해당 패키지명만 그대로 선언해주면 바로 사용할 수 있습니다. 다음은 콘솔에 값을 출력하는 코드입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 단일 import문은 이렇게 쓸 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 다중 import문은 이렇게 쓸 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그런데 &lt;code&gt;sensor.go&lt;/code&gt;의 &lt;code&gt;import&lt;/code&gt;문을 보면 &lt;code&gt;github.com/mingrammer/go-codelab/faker&lt;/code&gt;와 같이 조금 특이한 형태의 &lt;code&gt;import&lt;/code&gt;문을 볼 수 있습니다. Go는 Github나 Bitbucket와 같은 곳에 호스팅 되어있는 외부 패키지와 소스코드를 패키지로써 사용할 수 있게 해줍니다. 즉, 위 임포트문은 github.com에 호스팅 되어있는 mingrammer 유저의 &lt;code&gt;go-codelab/faker&lt;/code&gt; 패키지를 사용하겠다는 의미입니다. Go에서는 표준 라이브러리가 아닌 패키지의 경우 &lt;code&gt;$GOPATH/src&lt;/code&gt;를 기준으로 패키지를 불러오기 때문에 이런 외부 패키지가 &lt;code&gt;import&lt;/code&gt;문에 선언되어 있을 때  &lt;code&gt;go get&lt;/code&gt;이라는 명령어를 사용하면 해당 위치의 패키지 구조를 &lt;code&gt;$GOPATH/src&lt;/code&gt; 하위로 다운로드 받아 해당 패키지를 사용할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;다음 명령어를 통해 이제 튜토리얼을 다운로드 받아봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/mingrammer/go-codelab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;튜토리얼 설치가 끝나면 전체 Go 프로젝트 구조는 다음과 같아집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$GOPATH/
        bin/
        pkg/
        src/
                github.com/
                        mingrammer/
                                go-codelab/
                                        faker/
                                                range.go
                                        models/
                                                sensor.go
                                        sensor_client.go
                                        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 되면 어떤 Go 파일에서도 &lt;code&gt;github.com/mingrammer/go-codelab/&amp;lt;package name&amp;gt;&lt;/code&gt;를 &lt;code&gt;import&lt;/code&gt;에 선언하게되면 우리 프로젝트의 패키지를 사용할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;Go의 또 하나 특이한 점은 현재 사용되지 않는 패키지가 &lt;code&gt;import&lt;/code&gt;문에 선언되어 있을 경우엔 컴파일이 되지 않습니다. 즉, 미사용 패키지를 임포트하는걸 미연에 방지할 수 있습니다. 물론 &lt;code&gt;_ (blank indentifier)&lt;/code&gt;를 사용해 해당 패키지를 직접적으로 사용하지 않으면서 초기화를 위해 임포트하는 방법이 있긴 하지만 여기서는 다루지 않을 것입니다. 기본적으로 미사용 패키지의 임포트는 컴파일 에러를 발생시킨다는 것만 알아두면 됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>구조체와 인터페이스</title>
      <link>https://mingrammer.com/go-codelab/struct-and-interface</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/struct-and-interface</guid>
      <description>

&lt;p&gt;앞에서 잠깐 살펴본 모델 패키지 &lt;code&gt;models&lt;/code&gt;에는 클라이언트와 서버에서 사용할 센서들의 공용 메서드를 정의하는 &lt;code&gt;Sensor interface&lt;/code&gt;와 센서들의 공통 필드를 갖는 &lt;code&gt;SensorInfo struct&lt;/code&gt;를 정의해놓은 &lt;code&gt;sensor.go&lt;/code&gt; 파일이 있습니다.&lt;/p&gt;

&lt;p&gt;구조체와 인터페이스가 무엇인지 살펴보기 전에 실제 &lt;code&gt;sensor.go&lt;/code&gt;의 코드의 일부를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Sensor is common interface for any sensors&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// SensorInfo has common fields for any sensors&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서 보이는 &lt;code&gt;SensorInfo&lt;/code&gt;가 센서들의 공통 필드를 정의한 &lt;code&gt;struct&lt;/code&gt;이며 &lt;code&gt;Sensor&lt;/code&gt;가 센서들의 공용 메서드를 정의하는 &lt;code&gt;interface&lt;/code&gt;입니다. 그럼 이 &lt;code&gt;struct&lt;/code&gt;와 &lt;code&gt;interface&lt;/code&gt;가 무엇인지 우리 코드를 보며 자세히 살펴봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;구조체-struct&#34;&gt;구조체 (Struct)&lt;/h3&gt;

&lt;p&gt;구조체 &lt;code&gt;struct&lt;/code&gt;는 여러 필드를 가질 수 있는 일종의 확장 타입입니다. C 언어에서의 &lt;code&gt;struct&lt;/code&gt;와 거의 유사합니다.&lt;code&gt;struct&lt;/code&gt;는 다음과 같이 구성됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StructName&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;embededStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;varname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;vartype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`&amp;lt;tag&amp;gt;`&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;StructName&lt;/code&gt;은 구조체의 이름을 뜻하며 &lt;code&gt;varname&lt;/code&gt;은 필드명, &lt;code&gt;vartype&lt;/code&gt;은 필드의 타입, &lt;code&gt;tag&lt;/code&gt;는 잠시후 다시 설명할 해당 필드가 인코딩 되었을 때의 키값을 정의하는 태그입니다. 참고로 Go에서는 변수를 선언할 때 &lt;code&gt;var name type&lt;/code&gt;처럼 타입을 변수명 뒤에 선언합니다. 필드의 타입은 그 어떤 타입도 가능합니다. &lt;code&gt;embededStruct&lt;/code&gt;는 조금 이따 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;우선 실제 구조체를 살펴보기 위해 &lt;code&gt;SensorInfo&lt;/code&gt; 코드를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;name&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;type&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;GenTime&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;gen_time&amp;quot;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;StructInfo&lt;/code&gt; 구조체는 &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Gentime&lt;/code&gt;이라는 필드를 가지며 각각 &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;time.Time&lt;/code&gt;의 타입을 갖습니다. 그렇다면 뒤에 &lt;code&gt;json:&amp;quot;&amp;lt;tag&amp;gt;&amp;quot;&lt;/code&gt;는 무엇일까요? 위에서 이미 말했듯이 이는 인코딩 되었을 때의 키값을 정의합니다. 즉, 이 구조체를 &lt;code&gt;JSON&lt;/code&gt; 타입으로 인코딩 했을 때 해당 필드의 키값이 &lt;code&gt;tag&lt;/code&gt;로 설정된다는 뜻입니다. 위 구조체를 &lt;code&gt;JSON&lt;/code&gt;으로 인코딩하기 되면 다음과 같이 인코딩 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &#39;name&#39;: &#39;name value&#39;,
    &#39;type&#39;: &#39;type value&#39;,
    &#39;gen_time&#39;: &#39;gentime value&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 태그는 필수는 아니며 필요에 따라 선택적으로 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 아까 언급한 &lt;code&gt;embededStruct&lt;/code&gt;를 다시 살펴봅시다. &lt;code&gt;sensor.go&lt;/code&gt;에 있는 실제 코드를 보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// GyroSensor produces x-y-z axes angle velocity values&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityX&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;x_axis_angle_velocity&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityY&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;y_axis_angle_velocity&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityZ&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;z_axis_angle_velocity&amp;quot;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;sensor.go&lt;/code&gt;에 정의된 센서 구조체중 하나입니다. 여기에 선언되어 있는 &lt;code&gt;SensorInfo&lt;/code&gt;가 &lt;code&gt;Embedded struct&lt;/code&gt;이며 이는 &lt;code&gt;Embedding&lt;/code&gt;을 뜻합니다. 이는 다른 구조체의 정보를 그대로 가져와 사용하겠다는 뜻이며, 따라서 해당 구조체는 임베딩한 구조체의 모든 필드를 그대로 가질 수 있게됩니다. 즉, &lt;code&gt;GyroSensor&lt;/code&gt;는 &lt;code&gt;SensorInfo&lt;/code&gt;에 선언되어있는 모든 필드를 갖게됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Embedding&lt;/code&gt;을 사용하게되면 코드 중복을 피할 수 있으며, 코드의 재사용성이 증가하게 됩니다. 얼핏보면 Java, C++, Python에서의 상속과 비슷해 보이지만 다릅니다. 상속은 하위 클래스가 상위 클래스의 모든걸 가져오는 구조인 반면 &lt;code&gt;Embedding&lt;/code&gt;은 필요한 구조체의 필드들을 가져와 재사용하겠다는 의미를 가집니다. 즉, 일종의 구조체 모듈인셈입니다. Go 프로그래밍을 하게되면 앞으로 이러한 &lt;code&gt;Embedding&lt;/code&gt;을 많이 볼 수 있을 것입니다.&lt;/p&gt;

&lt;p&gt;구조체는 다음과 같이 사용할 수 있으며, 앞으로도 계속 보게될 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gyroSensor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// Embedded 구조체 필드의 경우 다음과 같이 초기화합니다.&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;&amp;quot;GyroSensor&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;&amp;quot;VelocitySensor&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;GenTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 자체 필드는 다음과 같이 초기화합니다.&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityZ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;인터페이스-interface&#34;&gt;인터페이스 (Interface)&lt;/h3&gt;

&lt;p&gt;인터페이스 &lt;code&gt;interface&lt;/code&gt;는 일종의 메서드 시그니쳐의 모음입니다. Java에서의 인터페이스와 유사하며, 어떤 타입이 특정 인터페이스의 메서드들을 모두 구현하고 있으면 그 타입은 해당 인터페이스 타입을 갖게됩니다. &lt;code&gt;interface&lt;/code&gt;는 다음과 같이 구성됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;InterfaceName&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;InterfaceName&lt;/code&gt;은 인터페이스의 이름을 뜻하며, &lt;code&gt;method signature&lt;/code&gt;는 메서드의 시그니쳐입니다.&lt;/p&gt;

&lt;p&gt;실제 인터페이스를 살펴보기 위해 &lt;code&gt;Sensor&lt;/code&gt; 코드를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;SendingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ReceivingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;GenerateSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt;라는 인터페이스에 &lt;code&gt;SendingOutputString() string&lt;/code&gt;, &lt;code&gt;ReceivingOutputString string&lt;/code&gt;, &lt;code&gt;GenerateSensorData(epsilon float64) Sensor&lt;/code&gt;라는 메서드 시그니쳐들이 있습니다. 만약 어떤 타입이 이 시그니쳐들을 갖는 메서드들을 모두 구현한다면 그 타입은 &lt;code&gt;Sensor interface&lt;/code&gt; 타입을 갖게되며, &lt;code&gt;Sensor&lt;/code&gt;를 인자로 받는 그 어떤 함수의 인자로도 들어갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 실제 &lt;code&gt;GyroSensor&lt;/code&gt; 구조체에 구현된 메서드들입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SendingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ReceivingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GenerateSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;GyroSensor&lt;/code&gt;는 &lt;code&gt;Sensor&lt;/code&gt; 인터페이스의 모든 메서드들을 구현하고 있으므로 &lt;code&gt;Sensor interface&lt;/code&gt; 타입이 됩니다. 즉, &lt;code&gt;Sensor&lt;/code&gt; 타입으로 사용할 수 있게 됩니다. 참고로 Go에서는 특정 타입의 메서드를 다음과 같이 선언할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// StructType 타입의 st 변수를 &amp;#39;리시버 (receiver)&amp;#39;라고 하며, 리시버를 특정 구조체 타입으로 선언하면 그 타입의 메서드가 됩니다.  &lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;st&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;returnTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// procssing with &amp;#39;st&amp;#39;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;결론적으로, 그 어떤 구조체라도 &lt;code&gt;Sensor&lt;/code&gt; 인터페이스의 세가지 메서드 시그니쳐들만 구현하면 &lt;code&gt;Sensor&lt;/code&gt;타입으로 사용할 수 있게됩니다. Go에서 인터페이스는 타입 호환성 및 확장성 측면에서 굉장히 중요한 개념으로 Go 프로그래밍을 하게되면 인터페이스를 자주 접할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전!&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;struct&lt;/code&gt;와 &lt;code&gt;interface&lt;/code&gt;를 사용해 다른 센서들처럼 호환 가능한 여러분만의 센서를 만들어보세요! 새로운 센서의 &lt;code&gt;GenerateSensorData&lt;/code&gt; 함수를 위한 여러분만의 랜덤 데이터 생성 함수를 &lt;code&gt;faker/range.go&lt;/code&gt;에도 추가해보세요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>클라이언트 구조</title>
      <link>https://mingrammer.com/go-codelab/client-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/client-structure</guid>
      <description>

&lt;p&gt;이전에 패키지를 다룰 때 우리는 메인 패키지라고 하는 조금 특별한 패키지에 대해 언급한 적이 있습니다. Go 프로그램이 실행가능한 바이너리 파일로 컴파일되기 위해선 메인 패키지가 반드시 필요합니다. 즉 실행 가능한 Go 프로그램들은 항상 메인 패키지를 가지고 있어야 하며 메인 패키지를 가진 프로그램은 반드시 &lt;code&gt;main&lt;/code&gt; 함수를 선언해야합니다. &lt;code&gt;main&lt;/code&gt; 함수는 조금 이따 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;클라이언트의-기본-동작-방식&#34;&gt;클라이언트의 기본 동작 방식&lt;/h3&gt;

&lt;p&gt;클라이언트 &lt;code&gt;sensor_client.go&lt;/code&gt;가 하는 일은 간단합니다. &lt;code&gt;models&lt;/code&gt;에 정의된 센서들로부터 일정 간격으로 센서 데이터를 생성하고 이를 서버에 보내는 역할을 합니다. 기본적인 플로우는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;센서값을 서버로 보내기위한 워커(worker)를 구동하기 위한 정보를 가진 워커 구조체를 정의합니다.&lt;/li&gt;
&lt;li&gt;고루틴(Goroutine)을 사용해 워커 정보의 갯수만큼 워커를 구동합니다.&lt;/li&gt;
&lt;li&gt;각 워커는 일정 간격으로 데이터를 생성해 서로 독립적으로 서버에 데이터를 전송합니다.&lt;/li&gt;
&lt;li&gt;서버 데이터 전송이 일정횟수가 넘어가면 모든 워커를 종료시켜 클라이언트 프로그램을 종료합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 플로우를 기반으로 실제 코드(&lt;code&gt;sensor_client.go&lt;/code&gt;)의 각 부분에 대해 자세히 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;워커-worker-와-카운터-counter-구조체-정의하기&#34;&gt;워커(worker)와 카운터(counter) 구조체 정의하기&lt;/h3&gt;

&lt;p&gt;우리는 각 센서 데이터를 독립적으로 서버에 보낼 수 있도록 고루틴 위에서 센서 워커를 돌릴 것 입니다. 따라서 워커를 돌리기 위해 필요한 정보들을 갖는 &lt;code&gt;worker&lt;/code&gt; 구조체를 정의할 것입니다. 고루틴에 대해선 다음 장에서 더 자세히 살펴볼 것이며 지금은 일단 경량 스레드쯤으로 이해하시면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Ticker&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;sensor&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;sensorError&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;serverPort&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;각 워커는 일정 간격마다 데이터를 생성 및 전송하므로 일정 간격마다 신호를 생성할 수 있는 &lt;code&gt;ticker&lt;/code&gt;를 필드로 넣습니다. 이 &lt;code&gt;ticker&lt;/code&gt;의 타입은 &lt;code&gt;*time.Ticker&lt;/code&gt;인데 이는 &lt;code&gt;time&lt;/code&gt;이라는 표준 라이브러리 패키지에 정의되어 있으며 원하는 주기마다 &lt;code&gt;Ticker&lt;/code&gt;로부터 신호를 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sensor&lt;/code&gt;는 각 센서 구조체들을 저장하기 위한 필드로 &lt;code&gt;Sensor&lt;/code&gt;의 타입으로 선언되어 있습니다. &lt;code&gt;Sensor&lt;/code&gt; 구조체는 &lt;code&gt;models&lt;/code&gt; 패키지에 존재하므로 &lt;code&gt;models.Sensor&lt;/code&gt;로 접근합니다. &lt;a href=&#34;https://mingrammer.com/go-codelab/struct-and-interface&#34;&gt;구조체와 인터페이스&lt;/a&gt;에서 보았듯이 &lt;code&gt;Sensor&lt;/code&gt; 인터페이스를 만족하면 그 어떤 구조체든 &lt;code&gt;Sensor&lt;/code&gt; 타입으로 선언이 가능합니다. 따라서, 종류와 상관없이 각 센서들을 저장할 수 있습니다. &lt;code&gt;serverError&lt;/code&gt;는 임의의 센서값을 생성할 때 사용되는 센서 오차값을 뜻하며 &lt;code&gt;serverPort&lt;/code&gt;는 각 센서별로 서버의 어느 포트로 데이터를 보낼지 설정하기 위한 필드입니다.&lt;/p&gt;

&lt;p&gt;또한 우리는 데이터 전송 횟수를 제한하기 위해 &lt;code&gt;counter&lt;/code&gt; 구조체를 정의할 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;바로 아래에서 살펴볼거지만 &lt;code&gt;counter&lt;/code&gt;의 경우 여러개의 고루틴에서 동시에 사용하기 때문에 필드값을 변경할 때 동기화 처리를 해줘야합니다. 다행히도 Go는 동기화와 관련된 기능들을 &lt;code&gt;sync&lt;/code&gt;라는 표준 라이브러리 패키지로 제공하고 있으며 &lt;code&gt;sycn.Mutex&lt;/code&gt;를 통해 뮤텍스 처리를 할 수 있도록 해줍니다. 따라서, &lt;code&gt;sync.Mutex&lt;/code&gt; 타입을 갖는 &lt;code&gt;mutex&lt;/code&gt;를 필드로 가지면 &lt;code&gt;count()&lt;/code&gt; 함수에서 볼 수 있듯이 특정값을 변경할 때 여러개의 고루틴이 동시에 값을 변경 할 수 없도록 &lt;code&gt;Lock&lt;/code&gt;을 걸 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 &lt;code&gt;worker&lt;/code&gt;와 &lt;code&gt;counter&lt;/code&gt;가 실제로 어떻게 사용되고 있는지 살펴봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;센서-워커-sensorworker-함수-살펴보기&#34;&gt;센서 워커 (sensorWorker) 함수 살펴보기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;worker&lt;/code&gt;에 정의된 워커 정보를 가지고 실제 센서 데이터를 서버로 보내는 워커 함수인 &lt;code&gt;sensorWorker&lt;/code&gt;를 살펴봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sensorWorker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// done 채널이 닫히기까지 대기&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// ticker 신호 대기&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;// 센서 데이터 생성&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensorData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sensorError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			 &lt;span class=&#34;c1&#34;&gt;// serverPort 값으로 서버 URL 생성&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;getRequestServerURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serverPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SendingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;

                        &lt;span class=&#34;c1&#34;&gt;// 서버로 데이터 전송&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sendJSONSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

                        &lt;span class=&#34;c1&#34;&gt;// 전송할 때 마다 카운팅&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;sensorWorker&lt;/code&gt;는 세 개의 인자를 받는데 각 인자는 다음을 의미합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;done &amp;lt;-chan struct{}&lt;/code&gt; : 고루틴을 종료하기 위한 신호를 받는 받기 전용 채널(channel)입니다. 채널에 대한 자세한 내용은 다음 장에서 살펴보겠습니다. 지금은 이 &lt;code&gt;done&lt;/code&gt;이 고루틴을 종료시키기 위한 채널 변수라고만 알아두면 됩니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w worker&lt;/code&gt; : 좀 전에 위에서 만든 &lt;code&gt;worker&lt;/code&gt;를 받는 인자입니다. 워커 정보를 받기 위한 인자입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c *counter&lt;/code&gt; : 전송 횟수를 카운팅 하기 위한 &lt;code&gt;*counter&lt;/code&gt; 변수입니다. 여러개의 고루틴에서 사용하기 위해 포인터 타입으로 선언하였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 함수는 무한 루프 안에서 &lt;code&gt;select/case&lt;/code&gt;문을 실행합니다. &lt;code&gt;switch/case&lt;/code&gt;문에 대해서는 다음 장에서 더 자세히 살펴볼 것이며 지금은 &lt;code&gt;case&lt;/code&gt;에 있는 채널에 값이 들어올 경우 해당 &lt;code&gt;case&lt;/code&gt; 아래의 코드가 실행된다는 것만 알아두시면 됩니다. 따라서 이는 &lt;code&gt;worker&lt;/code&gt;에 정의된 &lt;code&gt;ticker&lt;/code&gt;의 &lt;code&gt;C&lt;/code&gt; 채널로부터 신호를 받을 때마다 센서의 데이터를 생성하고 이를 서버로 전송합니다. 또한 &lt;code&gt;done&lt;/code&gt;에 값이 들어올 경우엔 &lt;code&gt;return&lt;/code&gt;을 실행하며 함수가 종료됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;main-함수-살펴보기&#34;&gt;main 함수 살펴보기&lt;/h3&gt;

&lt;p&gt;위에서 언급했듯이 메인 패키지는 반드시 &lt;code&gt;main&lt;/code&gt; 함수를 필요로하며 메인 패키지를 가진 Go 프로그램이 실행될 때 바로 이 &lt;code&gt;main&lt;/code&gt; 함수가 실행됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 전송 횟수 카운팅을 위한 카운터 생성 &lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sendCounter&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 동기화를 위한 일종의 세마포어. 이에 대해선 서버 섹션에서 자세히 설명하겠습니다.&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 상수는 const로 정의합니다.&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;numWorkers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 고루틴 종료 신호를 위한 채널 생성&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 워커의 갯수만큼의 카운트값을 갖는 세마포어 생성&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;numWorkers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;    
    
        &lt;span class=&#34;c1&#34;&gt;// 각각의 Ticker와 Sensor의 인스턴스를 생성해 worker에 저장합니다.&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;workerList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;numWorkers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NewTicker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;500&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0.5초 간격&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// GyroSensor 인스턴스&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensorError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;4.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;serverPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NewTicker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;500&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0.5초 간격&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AccelSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// AccelSensor 인스턴스&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensorError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;12.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;serverPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;8002&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NewTicker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 2초 간격&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// TempSensor 인스턴스&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensorError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;serverPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;8003&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// workerList를 순회하며 각 워커를 가져옵니다.&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// range로 순회하게되면 index와 value가 리턴되는데 현재는 index를 사용하지 않으므로 _로 무시합니다.&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;workerList&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sensorWorker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendCounter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 고루틴 하나가 끝났음을 알립니다.&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;c1&#34;&gt;// 전송 횟수를 체크하기 위한 고루틴&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sendCounter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
        
        &lt;span class=&#34;c1&#34;&gt;// 고루틴들이 종료되기 전까지 대기&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;	
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 함수에선 3개의 &lt;code&gt;worker&lt;/code&gt;를 만들고 &lt;code&gt;go&lt;/code&gt;키워드를 사용해 &lt;code&gt;sensorWorker&lt;/code&gt;를 실행하는 고루틴을 생성합니다. &lt;code&gt;go&lt;/code&gt; 키워드에 대해선 다음 장에서 고루틴/채널과 함께 자세히 설명할 것입니다.&lt;/p&gt;

&lt;p&gt;이렇게 3개의 고루틴을 생성하게 되면 각 고루틴은 &lt;code&gt;sensorWorker&lt;/code&gt;를 각각 독립적으로 실행하게되며, 각 워커마다 정의된 &lt;code&gt;Ticker&lt;/code&gt;의 주기에 따라 서버에 센서 데이터를 전송한 후 전송 횟수를 카운팅 할 것입니다.&lt;/p&gt;

&lt;p&gt;그런데 아래를 보면 또 하나의 고루틴을 생성하고 있는걸 볼 수 있습니다. 이 고루틴은 무한 루프를 돌며 카운터의 값을 체크하고 있는데 값이 100을 넘어가면 &lt;code&gt;done&lt;/code&gt; 채널을 닫은 후 &lt;code&gt;return&lt;/code&gt;으로 함수를 종료시킵니다. 이는 직관적으로 위에서 생성한 &lt;code&gt;sensorWorker&lt;/code&gt; 고루틴들의 데이터 전송 횟수가 100회를 넘어가면 고루틴들을 종료 시킨다는 것을 알 수 있습니다. 조금 더 자세히 말하자면, &lt;code&gt;done&lt;/code&gt; 채널을 닫게되면 &lt;code&gt;sensorWorker&lt;/code&gt;의 &lt;code&gt;case &amp;lt;-done:&lt;/code&gt;이 작동하게 되고 따라서 이 &lt;code&gt;case&lt;/code&gt;문의 코드인 &lt;code&gt;return&lt;/code&gt;이 실행되면서 모든 &lt;code&gt;sensorWorker&lt;/code&gt; 고루틴들이 종료됩니다.&lt;/p&gt;

&lt;p&gt;즉, 클라이언트 프로그램은 센서의 갯수만큼 워커 고루틴들을 생성하여 주기적으로 센서 데이터를 서버로 전송하며,  총 전송 횟수가 100회를 넘어가면 모든 고루틴을 종료하고 프로그램을 종료하는 방식으로 동작함을 알 수 있습니다!&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전!&lt;/h3&gt;

&lt;p&gt;이전 장에서 만든 센서를 위한 워커를 생성하여 여러분만의 센서 데이터를 전송해보세요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>고루틴과 채널</title>
      <link>https://mingrammer.com/go-codelab/goroutine-and-channel</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/goroutine-and-channel</guid>
      <description>

&lt;p&gt;이번에는 이전 장에서 많이 등장했던 고루틴과 채널에 대해 간단히 다뤄보도록 하겠습니다. 고루틴과 채널은 Go에서 굉장히 중요한 개념입니다. 이 장에서는 우리 튜토리얼에서 필요한 만큼의 설명만 하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;고루틴&#34;&gt;고루틴&lt;/h3&gt;

&lt;p&gt;Go에서 &lt;code&gt;고루틴(Goroutine&lt;/code&gt;)이란, Go 런타임에 의해 관리되는 경량 스레드입니다. 고루틴을 사용하면 비동기적으로 여러개의 함수를 실행할 수 있으며 우리는 이를 활용해 각 센서 데이터를 동시에 서버에 전송할 수 있습니다.&lt;/p&gt;

&lt;p&gt;고루틴은 &lt;code&gt;go&lt;/code&gt; 키워드를 사용해 생성할 수 있는데 두 가지 방법으로 생성할 수 있습니다. 하나는 일반 함수를 사용하는 것이며 다른 하나는 익명 함수를 사용하는 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;work&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 일반 함수로 고루틴 생성&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;work&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        
        &lt;span class=&#34;c1&#34;&gt;// 익명 함수로 고루틴 생성&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;고루틴은 &lt;code&gt;main&lt;/code&gt; 함수와는 독립적으로 실행되지만 &lt;code&gt;main&lt;/code&gt; 함수가 종료되면 모든 고루틴들이 종료됩니다. 따라서 고루틴보다 &lt;code&gt;main&lt;/code&gt;이 먼저 종료되는걸 방지하기위해 &lt;code&gt;sync&lt;/code&gt; 라이브러리에 있는 &lt;code&gt;WaitGroup&lt;/code&gt;이라는 세마포어를 활용해 고루틴의 종료를 대기하는 방법이 있는데 이는 서버 섹션에서 다룰 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;채널&#34;&gt;채널&lt;/h3&gt;

&lt;p&gt;근데 만약에 고루틴을 사용하다가 고루틴끼리 데이터를 주고 받아야하는 경우가 생기면 어떻게 해야할까요? 바로 &lt;code&gt;채널(Channel)&lt;/code&gt;을 사용하면 됩니다. 채널이란 동시에 실행되는 고루틴들을 연결해주는 일종의 파이프(pipe)입니다.&lt;/p&gt;

&lt;p&gt;채널을 사용하면 고루틴에서 다른 고루틴으로 값을 전달할 수 있으며 다른 고루틴으로부터 값을 전달받을 수도 있습니다. 채널은 &lt;code&gt;chan&lt;/code&gt; 키워드로 생성할 수 있으며 채널에 들어가는 데어터는 그 어떤 타입이라도 가능합니다. 예를 들면 정수값을 주고받는 채널의 경우 다음과 같이 선언할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 고루틴끼리 채널을 통해 데이터를 주고 받을 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 채널에 값을 넣습니다.&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 채널로부터 값을 받습니다.&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 출력값 : data&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// string 채널을 위한 메모리를 할당합니다.&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위에서 볼 수 있듯이 채널은 기본적으로 데이터를 주고 받을 수 있는 양방향 파이프입니다. 그런데 프로그램을 개발하다보면 어떤 고루틴은 받기만, 또 어떤 고루틴은 보내기만 하는 경우가 생길 수 있습니다. 이 경우엔 양방향 채널을 쓰는 대신 단방향 채널을 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 보내기 전용 단방향 채널을 사용합니다.&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 채널에 값을 넣습니다.&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 받기 전용 단방향 채널을 사용합니다.&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routine2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 채널로부터 값을 받습니다.&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 출력값 : data&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;마지막으로, 어떤 고루틴이 특정 채널로부터 값을 받기까지 대기해야 하는 상황을 생각해봅시다.  바로 이 때 우리가 이전 장에서 보았던 &lt;code&gt;switch/case&lt;/code&gt;문을 사용할 수 있습니다. Go에서의 &lt;code&gt;switch/case&lt;/code&gt;문은 우리가 원래 알고 있던 그것과 동일합니다. 다만, Go에서는 이를 채널과 함께 사용할 수도 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitFromChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;yourChannel&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Received from ourChannel&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;yourChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Received %s from yourChannel&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 &lt;code&gt;waitFromChannel&lt;/code&gt; 고루틴이 현재 &lt;code&gt;ourChannel&lt;/code&gt;과 &lt;code&gt;yourChannel&lt;/code&gt;로부터 값이 들어올 때까지 대기하고 있음을 나타냅니다. &lt;code&gt;case&lt;/code&gt;에 채널을 사용하면 해당 &lt;code&gt;case&lt;/code&gt;는 채널로부터 값이 들어오기까지 대기합니다. 대기하다가 해당 채널에 값이 들어오면 해당 &lt;code&gt;case&lt;/code&gt;문 아래의 코드가 실행됩니다. 만약 다른 고루틴에서 &lt;code&gt;yourChannel&lt;/code&gt;에 &lt;strong&gt;&amp;ldquo;go&amp;rdquo;&lt;/strong&gt;라는 값을 넣게되면 &lt;code&gt;waitFromChannel&lt;/code&gt;의 &lt;code&gt;case val := yourChannel&lt;/code&gt;에서 값을 받게되고 아래의 출력문이 실행되어 &lt;strong&gt;&amp;ldquo;Received go from yourChannel&amp;rdquo;&lt;/strong&gt;가 출력됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>서버 구조 및 net/http</title>
      <link>https://mingrammer.com/go-codelab/server-structure-and-net-http</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/server-structure-and-net-http</guid>
      <description>

&lt;h3 id=&#34;server-의-기본-동작-방식&#34;&gt;&lt;code&gt;Server&lt;/code&gt;의 기본 동작 방식&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;는 기본적으로 3개의 포트 번호에 대한 HTTP 서버를 생성합니다. 각 포트 번호를 달리한 것은 서로 다른 종류의 센서값을 받기 위함이며, 각 번호는 다음의 의미를 갖습니다.&lt;/p&gt;

&lt;h4 id=&#34;8001번은-자이로스코프-센서의-데이터를&#34;&gt;8001번은 자이로스코프 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8002번은-가속도-센서의-데이터를&#34;&gt;8002번은 가속도 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8003번은-온도-및-습도계의-데이터를-받습니다&#34;&gt;8003번은 온도 및 습도계의 데이터를 받습니다.&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt;의 코드에서 봤듯이, HTTP 프로토콜을 이용하기 위해선 &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; 패키지가 필요합니다. &lt;code&gt;Sensor&lt;/code&gt; 클라이언트에서는 단순히 POST 요청을 보내면 되므로 패키지를 &lt;code&gt;import&lt;/code&gt;하고 필요한 API를 사용하는 것으로 끝났습니다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code&gt;net/http&lt;/code&gt; 패키지에서 서버를 생성하는 메서드인 &lt;a href=&#34;https://golang.org/pkg/net/http/#ListenAndServe&#34;&gt;&lt;code&gt;ListenAndServe()&lt;/code&gt;&lt;/a&gt; 메서드를 확인해보면, 인자로 &lt;a href=&#34;https://golang.org/pkg/net/http/#Handler&#34;&gt;&lt;code&gt;Handler Interface&lt;/code&gt;&lt;/a&gt;를 요구하고 있습니다. 이 &lt;code&gt;Handler Interface&lt;/code&gt;를 다시 확인해보면, 결국 &lt;a href=&#34;https://golang.org/pkg/net/http/#HandlerFunc&#34;&gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;라는 메서드를 요구합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;handler-interface-구현하기&#34;&gt;&lt;code&gt;Handler Interface&lt;/code&gt; 구현하기&lt;/h3&gt;

&lt;p&gt;우리는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드가 구현된 &lt;code&gt;Handler Interface&lt;/code&gt;가 필요하므로  &lt;code&gt;Handler Interface&lt;/code&gt;를 만족시키기 위한 각 센서에 대한 핸들러를 정의해줘야 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위의 핸들러들이 &lt;code&gt;Handler Interface&lt;/code&gt;를 만족하기 위해선 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 구현해야 합니다. 구조체의 메서드를 정의하기위해 &lt;code&gt;Pointer Receiver&lt;/code&gt;를 사용합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 온도계 및 습도계에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 자이로 센서에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 가속도 센서에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;데이터-까보기&#34;&gt;데이터 까보기&lt;/h3&gt;

&lt;p&gt;이제 HTTP 프로토콜을 통해서 받은 데이터를 디코딩해봅시다. 먼저, HTTP를 통해 받은 데이터는 &lt;code&gt;Request&lt;/code&gt;에 들어있겠죠? 그래서 우리는 &lt;code&gt;*http.Request&lt;/code&gt; 객체를 사용하겠습니다. 클라이언트 측에선 센서에 대한 데이터를 JSON 형식으로 보냈습니다. 따라서 우리는 Go언어에서 제공해주는 &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshal&#34;&gt;JSON 패키지&lt;/a&gt;의 &lt;code&gt;NewDecoder()&lt;/code&gt; 메서드를 이용해 다음과 같이 데이터를 디코딩하겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempSensor&lt;/span&gt;					&lt;span class=&#34;c1&#34;&gt;// 해독한 데이터를 저장할 공간을 만들어줍니다.&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;decoder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NewDecoder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Request의 Body를 해독하기 위해 JSON 패키지에서 Decoder를 새로 생성해줍니다.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;decoder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Decode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;				&lt;span class=&#34;c1&#34;&gt;// 생성한 Decoder를 이용해서 데이터를 해독하고 저장합니다.&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;										&lt;span class=&#34;c1&#34;&gt;// 해독하는 중 발생할 수 있는 에러를 처리하기 위한 문구입니다. 이건 다음 페이지에서 설명할게요 :)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Error Occurred When Parsing Temperature Data&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;							&lt;span class=&#34;c1&#34;&gt;// Request의 Body를 더 이상 읽을 필요가 없으면 닫아줍니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그럼 해독한 데이터를 어떻게 로그 핸들러에게 전달해줘야할까요? 이것은 다음 페이지에서 자세하게 얘기할게요. 대신 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드 마지막에 이 코드만 추가해주세요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tempLog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sensorName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 다음 페이지에선 해독한 데이터를 로그 핸들러에게 전달해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전!&lt;/h3&gt;

&lt;p&gt;남은 기본 센서들과 이전 단계에서 만들었던 여러분들만의 센서에 대해 &lt;code&gt;Handler Struct&lt;/code&gt;와 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 정의해보세요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>서버에서의 채널 동작 방식 및 로그 핸들러</title>
      <link>https://mingrammer.com/go-codelab/how-server-and-logger-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-server-and-logger-works</guid>
      <description>

&lt;h3 id=&#34;data-pipe으로서-channel&#34;&gt;Data Pipe으로서 Channel&lt;/h3&gt;

&lt;p&gt;이렇게 &lt;code&gt;Server&lt;/code&gt;는 HTTP Protocol을 통해 받은 데이터를 로그 파일에 남길 형식으로 가공하여 로그 핸들러에게 전달해줍니다. 여기서 로그 핸들러는 &lt;code&gt;sensor_server.go&lt;/code&gt;에서 함수로 구현되어 현재 고루틴 상에서 실행되고 있습니다. 그렇다면 각 HTTP 핸들러는 로그 핸들러인 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드에게 데이터를 어떻게 보내야할까요? 여기서 사용되는 것이 채널입니다.&lt;/p&gt;

&lt;p&gt;sensor_server.go 내에서 &lt;code&gt;LogContent&lt;/code&gt;에 대한 채널을 만들어줍니다. 그리고 이 채널을 &lt;code&gt;ServeHTTP()&lt;/code&gt;를 구현한 각 핸들러 구조체를 생성할 때 인자로 같이 넘겨줍니다. 물론 이렇게 사용하려면, 구조체 정의에서도 다음과 같이 정의해줘야 사용할 수 있겠죠?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이렇게 되면 각 구조체는 해당 채널에 대한 사용권을 받게 됩니다. &lt;code&gt;ServeHTTP()&lt;/code&gt;메서드에서 채널에 대한 사용권을 얻으려면 &lt;code&gt;m.buf&lt;/code&gt;로 접근해주면 됩니다. (이전 페이지에서 마지막에 추가한 코드가 이제 이해가 가겠죠?)
마찬가지로, 로그를 남기는 역할을 하는 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드도 채널 사용권을 인자로 넘겨받습니다. 이렇게 되면 데이터를 보내야할 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드와 데이터를 받아야할 &lt;code&gt;Log Handler&lt;/code&gt;가 채널을 통해 데이터를 교환할 수 있는 환경이 만들어졌습니다!&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;양방향-채널-단방향-채널&#34;&gt;양방향 채널? 단방향 채널!&lt;/h3&gt;

&lt;p&gt;여려분이 만들 프로그램은 각 데이터 종류에 대한 핸들러와 &lt;code&gt;fileLogger()&lt;/code&gt;메서드가 채널을 사용합니다. 만약 각 요소에서 데이터를 활용할 방향성에 대해 정의하지 않으면, 자신의 권한과 상관없이 데이터를 마음껏 저장하고 불러올 수 있겠죠. 이건 우리가 이상적으로 생각하는 모습이 아닙니다. 그래서 우리는 각 핸들러와 메서드가 사용할 채널의 방향성을 지정해줌으로서 파이프에서의 데이터의 흐름을 한 방향으로 보장하도록 하려고 합니다. 고맙게도 Go언어에서는 이에 대해서도 미리 &lt;a href=&#34;https://golang.org/ref/spec#Channel_types&#34;&gt;준비&lt;/a&gt;를 해놨습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;        		  &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 사용권을 받으면 채널에서 T 타입 데이터를 불러오고 저장할 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 받게 되면 채널에서 T 타입 데이터를 불러오기만 할 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;     	 &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 받으면 T 타입 데이터를 채널에 저장만 할 수 있습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그렇다면 우리는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드에선 채널에서 데이터를 보내기만 하도록, &lt;code&gt;fileLogger()&lt;/code&gt; 메서드에선 채널에서 데이터를 받기만 하도록 지정해줘야겠죠. 따라서 우리는 각 메서드의 정의에서 채널의 방향성을 아래와 같이 지정해줘야합니다. 이렇게 바꿔주면 에러가 날까봐 걱정인가요? 지금까지 잘 따라왔다면 에러없이 잘 작동할 것입니다 :)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;로그-로그를-보자&#34;&gt;로그, 로그를 보자!&lt;/h3&gt;

&lt;p&gt;이제 로그를 남겨봅시다! 로그는 각 센서별로 정보를 모아서 저장을 할 것입니다. 이미 눈치 채신 분들이 있겠지만, 이미 프로젝트 폴더에 로그라는 폴더가 존재합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log/
		Accel.log
		Gyro.log
		Temp.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;약어가 의미하듯이 &lt;code&gt;Accel.log&lt;/code&gt;는 가속도 센서의 측정값을, &lt;code&gt;Gyro.log&lt;/code&gt;는 자이로 센서의 측정값을, 그리고 &lt;code&gt;Temp.log&lt;/code&gt;는 온도 및 습도계의 측정값을 저장합니다. 로그를 본격적으로 저장하기 전에, 우리가 로그를 저장할 폴더가 존재하는지 확인해야합니다. 이를 외해 &lt;a href=&#34;https://golang.org/pkg/os/#Open&#34;&gt;&lt;code&gt;os.Open(&#39;log&#39;)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 사용할 것입니다.만약 이 메서드가 로그 폴더를 정상적으로 찾아내면, 그에 대한 파일 타입을 반환할 것입니다. 아닐 경우, 로그 폴더를 &lt;a href=&#34;https://golang.org/pkg/os/#Mkdir&#34;&gt;&lt;code&gt;os.Mkdir(&#39;log&#39;, os.ModePerm)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 이용해 생성할 것입니다.&lt;/p&gt;

&lt;p&gt;로그 폴더가 정상적으로 존재하는 경우, &lt;code&gt;Log Handler&lt;/code&gt;인 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드는 채널에 값이 들어오기를 기다립니다. 아래의 &lt;code&gt;for := range&lt;/code&gt; 문이 그 역할을 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for logData := range logStream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;for := range&lt;/code&gt; 문은 &lt;code&gt;main()&lt;/code&gt; 함수에서 전달받은 채널에 데이터가 존재할지 기다리고, 존재하는 경우 바로 내부 코드를 실행합니다. 이런 과정은 프로그램이 강제로 종료하거나, 외부에서 채널을 종료(Close)하기까지 계속 반복됩니다.&lt;/p&gt;

&lt;p&gt;채널에 데이터가 들어오게 되면 받은 데이터 구조체에서 해당 데이터가 저장될 위치를 읽어와 이를 디렉토리 주소로 조합하고 해당 로그 파일을 열게됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;joinee&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logDir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;joinee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OpenFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_CREATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_WRONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_APPEND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0666&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;해당 파일이 정상적으로 열릴 경우, 다음 단계로 넘어가면 됩니다. (만약 에러가 발생하면 이에 대한 예외처리가 필요합니다.) 이제 파일에 로그를 남겨줄 &lt;code&gt;logger&lt;/code&gt;를 만들겁니다. 여기서 우리는 &lt;a href=&#34;https://golang.org/pkg/log&#34;&gt;log 패키지&lt;/a&gt;를 이용해 직접 해당 파일로 로그를 남기는 &lt;code&gt;logger&lt;/code&gt;를 직접 만들어보겠습니다. 아래의 &lt;a href=&#34;https://golang.org/pkg/log/#New&#34;&gt;New()&lt;/a&gt; 메서드는 특정 &lt;code&gt;Writer&lt;/code&gt; 인터페이스로 로그를 남길 수 있도록 합니다. 여러분의 경우, 파일에 로그를 남기기로 했으니, 위에서 열어준 &lt;code&gt;fileHandle&lt;/code&gt;을 이용하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LstdFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;[%s Data Received]\n%s\n&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sensorName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이렇게 생성한 &lt;code&gt;logger&lt;/code&gt;를 이용해 로그 내용을 출력하게 되면 다음과 같은 결과를 로그 파일에서 확인할 수 있습니다. 결과값은 &lt;code&gt;main()&lt;/code&gt; 메서드에서 실제로 핸들러와 &lt;code&gt;logger&lt;/code&gt;를 실행해서 결과를 확인해봅시다!&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;일해라-서버야&#34;&gt;일해라 서버야!&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;main()&lt;/code&gt; 함수에서 우리가 정의해줬던 것들을 실제로 실행해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, HTTP 핸들러 메서드에서 로그 핸들러로 기록할 로그의 내용을 전달해주는 채널, 각 센서에 대한 핸들러를 선언해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;gyroHander&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;accelHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;tempHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그 다음엔 실제 HTTP 서버를 실행하는 &lt;code&gt;ListenAndServe()&lt;/code&gt; 메서드를 실행합니다. 여기서 주의할 것은, 그냥 실행하면 맨 위의 한 개 서버만 생성이 됩니다. &lt;code&gt;ListenAndServe()&lt;/code&gt; 메서드가 실행되면 그 즉시 해당 핸들러에 대해 HTTP 요청을 대기 시작하기 때문입니다. 우리는 3개의 센서에 대한 서버가 동시에 돌아가는 것을 윈하죠? 이 때 고루틴으로 실행합니다! 단순히 실행할 메서드 앞에 &lt;code&gt;go&lt;/code&gt;를 붙여주면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8001&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gyroHander&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8002&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;accelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8003&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그리고 동시에 파일&lt;code&gt;logger&lt;/code&gt;도 실행이 되어야겠죠? &lt;code&gt;fileLogger()&lt;/code&gt; 함수도 고루틴을 이용해 실행해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 바로 실행을 해볼까요? 실행이 잘 되나요? 아마 안 될 겁니다. 왜냐하면 고루틴들이 일을 하고 있지만, 프로그램 메인 프로세스가 먼저 종료되었기 때문입니다. 기본적으로 고루틴들이 종료되기를 기다리지 않는다는 것이죠. 그래서 우리는 메인 스레드가 고루틴을 기다릴 수 있도록 한 가지를 더 추가할 것입니다. 바로 &lt;a href=&#34;https://golang.org/pkg/sync/#WaitGroup&#34;&gt;&lt;code&gt;WaitGroup&lt;/code&gt;&lt;/a&gt;입니다. 이 &lt;code&gt;WaitGroup&lt;/code&gt;은 일종의 카운팅 세마포어로, &lt;code&gt;Wait()&lt;/code&gt;이라는 메서드를 사용해서 고루틴들이 끝나기 까지 기다려야하지만, 그 전에 얼마나 많은 고루틴을 기다려야하는지를 정의해야합니다. 이 때 우리는 &lt;code&gt;Add()&lt;/code&gt; 메서드를 이용하여, 기다려야하는 고루틴의 갯수를 &lt;code&gt;WaitGroup&lt;/code&gt;에 지정합니다. 우리의 경우 4개의 고루틴을 기다려야겠죠? (주의할 것은 &lt;code&gt;WaitGroup&lt;/code&gt;은 &lt;code&gt;sync&lt;/code&gt; 패키지에 정의되어 있는 타입이기 때문에 이 또한 &lt;code&gt;import&lt;/code&gt;해줘야 합니다!!)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;sync&amp;quot;&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그리고 고루틴들을 실행하고 기다려주도록 &lt;code&gt;Wait()&lt;/code&gt; 메서드를 실행해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code&gt;WaitGroup&lt;/code&gt;까지 만들어줬으면 프로그램을 실행하기 위한 코드들을 모두 추가했습니다! 다음 페이지에선 실제로 어플리케이션을 실행하고 결과를 확인해보곘습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전!&lt;/h3&gt;

&lt;p&gt;여러분들이 직접 정의했던 센서들에 대해서도 단방향 채널과 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 정의하고 &lt;code&gt;fileLogger()&lt;/code&gt;에서 정상적으로 출력하게 해보세요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>에러 핸들링</title>
      <link>https://mingrammer.com/go-codelab/error-handling-in-go</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/error-handling-in-go</guid>
      <description>

&lt;h3 id=&#34;리턴값이-여러개&#34;&gt;리턴값이 여러개!&lt;/h3&gt;

&lt;p&gt;Go언어에서 에러 핸들링을 논하기 전에, Go 언어의 가장 강력한 특징을 하나 소개하려고 합니다. Go 언어는 &lt;code&gt;Multiple Return&lt;/code&gt;(다중 리턴)을 지원합니다! 대부분의 프로그래밍 언어들은 단일 리턴만을 지원했지만, Go 언어에선 다중 리턴을 지원해줍니다. 아래의 코드를 한 번 볼까요?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;functionName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReturnType1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReturnType2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RetrunValue1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReturnValue2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위의 함수 정에서 뒤쪽에 리턴값을 정의하는 부분을 볼까요? 괄호를 이용해서 두 개의 리턴타입을 정해줬습니다. 그리고 리턴 문구에서는 반환할 두 개의 값을 지정해주고 있습니다. 그렇다면 이 메서드를 불렀을 때 두 개의 리턴값을 어떻게 받아야할까요?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;returnValue1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;returnValue2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;input1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;input2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;간단합니다! 메서드를 정의할 때 의미했던 리턴값들을 저장할 변수를 컴마(,)로 구분하여 차례대로 할당을 받으면 됩니다. (보통 짧은 선언문을 이용해서 바로 할당받아 사용합니다.)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;에러-핸들링의-실체&#34;&gt;에러 핸들링의 실체&lt;/h3&gt;

&lt;p&gt;그럼 이전에 로그파일을 열어줄 때 사용했던 &lt;code&gt;os.OpenFile()&lt;/code&gt; 메서드를 다시 볼까요?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OpenFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_CREATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_WRONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_APPEND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0666&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;fileHandle&lt;/code&gt;이라는 값 이외에도 err라는 값을 할당받을 수 있군요. 그럼 이것은 어떤 것을 의미할까요? &lt;code&gt;os.OpenFile()&lt;/code&gt; 메서드의 정의를 한 번 확인해보죠!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OpenFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;perm&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FileMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;File&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;리턴값의 종류를 확인해보면 &lt;code&gt;*File&lt;/code&gt;이라는 타입과 &lt;code&gt;error&lt;/code&gt;라는 타입을 받을 수 있음을 확인할 수 있습니다. &lt;code&gt;*File&lt;/code&gt; 타입은 특정파일에 대한 &lt;code&gt;FileHandle&lt;/code&gt;임을 알 수 있습니다. 그렇다면 &lt;code&gt;error&lt;/code&gt;라는 타입은 어떤 것일까요? 이는 &lt;a href=&#34;https://golang.org/pkg/builtin/#error&#34;&gt;Go언어 자체에서 에러들을 표현하기 위해 만든 &lt;code&gt;Interface&lt;/code&gt;&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;error 인터페이스는 &lt;code&gt;Error()&lt;/code&gt;라는 메서드를 가지며, 인터페이스가 불리게 될 경우, 다시 말해 에러가 발생할 경우 &lt;code&gt;Error()&lt;/code&gt;라는 인터페이스는 해당 에러의 정보를 반환합니다. 에러가 발생하지 않는다면 이러한 에러 인터페이스는 발생하지 않고, 이를 리턴 타입으로 가지는 메서드에서는 이에 대해 nil값을 반환하게 됩니다. (에러가 없으니 당연히 존재하지 않겠죠?) 따라서 우리가 특정 파일을 열고, 여기에 문제가 있는지 확인하기 위해선 다음과 같이 구성하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OpenFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_CREATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_WRONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_APPEND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0666&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Error Opening File\n&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LstdFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전!&lt;/h3&gt;

&lt;p&gt;이 프로그램에선 &lt;code&gt;erorr&lt;/code&gt;를 반환하는 메서드가 많이 있습니다. 이 메서드들을 찾아서 발생할 수 있는 각 에러에 대한 메세지를 직접 정의해보세요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>애플리케이션 동작 과정</title>
      <link>https://mingrammer.com/go-codelab/how-application-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-application-works</guid>
      <description>

&lt;h3 id=&#34;go-어플리케이션-실행-방법&#34;&gt;Go 어플리케이션 실행 방법&lt;/h3&gt;

&lt;p&gt;이제 우리 튜토리얼이 모두 완성되었습니다! 이제 직접 실행해볼까요? Go로 제작한 어플리케이션은 두 가지 방식으로 실행할 수 있습니다. 하나는 컴파일과 동시에 실행, 다른 하나는 실행 파일을 제작하고 실행하는 것입니다. 컴파일과 동시에 실행할 경우, 실행파일을 남기지 않고 실행합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lkaybob@lkaybob-530u4c:~$ go run sample.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 실행파일을 따로 만들고 싶다면 &lt;code&gt;build&lt;/code&gt;를 하면 됩니다. 이럴 경우, 원본 소스파일의 이름으로 바이너리 형태의 실행파일이 만들어집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lkaybob@lkaybob-530u4c:~$ go build sample.go
lkaybob@lkaybob-530u4c:~$ ls
sample.go 			sample*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;우와-실행된다&#34;&gt;우와 실행된다&amp;hellip;!&lt;/h3&gt;

&lt;p&gt;먼저 터미널(혹은 명령 프롬프트) 창을 2개 열어놓습니다. 먼저 한 쪽에서 클라이언트쪽 코드를 실행해봅니다. 그러나 실행해보면 에러를 반환하면서 프로그램이 강제로 종료됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lkaybob@lkaybob-530u4c:~/GoDev/src/github.com/mingrammer/go-codelab$ go run sensor_client.go 
[VelocitySensor] SENT : AccelerometerSensor : 238.999997, 480.007518, 529.467091
[VelocitySensor] SENT : GyroSensor : 221.278028, 196.978569, 237.693392
2016/11/17 22:52:18 Error occurs when request the post data
exit status 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 클라이언트 코드를 작성할 당시, HTTP 프로토콜로 요청을 보냈지만, 현재 데이터가 존재하지 않기 때문에 에러를 반환하고 종료하도록 정의했기 때문입니다.&lt;/p&gt;

&lt;p&gt;그럼 이번엔 다른 한 쪽에서 서버를 먼저 실행해보겠습니다. 실행할 경우, 아무것도 안 뜨면서 커서만 깜박거릴 것입니다. 에러가 난 것이나고요? 아닙니다. 지극히 정상적인 것입니다. 클라이언트 측에서 데이터를 받으면 서버는 이에 반응을 할 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lkaybob@lkaybob-530u4c:~/GoDev/src/github.com/mingrammer/go-codelab$ go run sensor_server.go 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 클라이언트 코드를 실행해볼까요? 실행을 하면 잠시 후 콘솔창에 로그들이 찍히는 것을 확인할 수 있습니다. 아래는 클라이언트 측의 실행결과입니다. 각 센서의 측정값들이 정상적으로 전송되었음을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[VelocitySensor] SENT : GyroSensor : 191.977586, 245.389473, 236.617520
[VelocitySensor] SENT : AccelerometerSensor : 554.004670, 155.890607, 639.557394
[VelocitySensor] SENT : GyroSensor : 239.264445, 175.081075, 25.573417
[VelocitySensor] SENT : AccelerometerSensor : 670.593904, 114.496005, 272.511751
[VelocitySensor] SENT : AccelerometerSensor : 1033.903791, 441.048931, 454.012025
[VelocitySensor] SENT : GyroSensor : 73.746588, 200.838994, 363.733532
[AtmosphericSensor] SENT : TemperatureSensor : 88.013658, 32.216430
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 서버측 콘솔 화면을 보겠습니다. 실행을 했을 당시만 해도 꿈쩍을 안 하던 콘솔 화면이 변화를 보였습니다! 서버 측은  먼저 도달한 데이터 순으로 차례대로 처리하며 해당 데이터를 처리했음을 콘솔 화면에서 보여줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[VelocitySensor] RECEIVED : GyroSensor : 191.977586, 245.389473, 236.617520
[VelocitySensor] RECEIVED : AccelerometerSensor : 554.004670, 155.890607, 639.557394
[VelocitySensor] RECEIVED : GyroSensor : 239.264445, 175.081075, 25.573417
[VelocitySensor] RECEIVED : AccelerometerSensor : 670.593904, 114.496005, 272.511751
[VelocitySensor] RECEIVED : AccelerometerSensor : 1033.903791, 441.048931, 454.012025
[VelocitySensor] RECEIVED : GyroSensor : 73.746588, 200.838994, 363.733532
[VelocitySensor] RECEIVED : GyroSensor : 154.033246, 335.525676, 24.761997
[VelocitySensor] RECEIVED : AccelerometerSensor : 480.081296, 148.277650, 491.804754
[AtmosphericSensor] RECEIVED : TemperatureSensor : 88.013658, 32.216430
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다만 표시되는 데이터 순서가 다를 수 있지만, 이것은 서버 측 채널에 먼저 도달한 순서대로 표시하기 때문에 일부 차이가 있을 수 있습니다. 이제 로그에 어떻게 기록되었는지 확인해볼까요? &lt;code&gt;Accel.log&lt;/code&gt;를 먼저 열어봤습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/11/17 23:02:06 [AccelerometerSensor Data Received]
Measured on 2016-11-17 23:02:06.996888976 +0900 KST
Gravitational Velocity of X-axis : 554.004670
Gravitational Velocity of Y-axis : 155.890607
Gravitational Velocity of Z-axis : 639.557394

2016/11/17 23:02:07 [AccelerometerSensor Data Received]
Measured on 2016-11-17 23:02:07.496897415 +0900 KST
Gravitational Velocity of X-axis : 670.593904
Gravitational Velocity of Y-axis : 114.496005
Gravitational Velocity of Z-axis : 272.511751

2016/11/17 23:02:07 [AccelerometerSensor Data Received]
Measured on 2016-11-17 23:02:07.996894498 +0900 KST
Gravitational Velocity of X-axis : 1033.903791
Gravitational Velocity of Y-axis : 441.048931
Gravitational Velocity of Z-axis : 454.012025

2016/11/17 23:02:08 [AccelerometerSensor Data Received]
Measured on 2016-11-17 23:02:08.49689645 +0900 KST
Gravitational Velocity of X-axis : 480.081296
Gravitational Velocity of Y-axis : 148.277650
Gravitational Velocity of Z-axis : 491.804754

.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아주 잘 정돈된 형식으로 기록되어 있습니다! 다른 센서들에 대한 로그 파일도 열어보면 각 센서에 맞는 형식으로 아주 정돈된 형태로 기록이 남아있을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전&lt;/h3&gt;

&lt;p&gt;여러분이 직접 정의했던 센서들에 대해서도 로그가 잘 남는지 확인해보세요. 안 된다면 어디서 문제인지 한 번 찾아보고 해결해보세요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>축하합니다!</title>
      <link>https://mingrammer.com/go-codelab/next-to-go</link>
      <pubDate>Thu, 17 Nov 2016 23:41:33 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/next-to-go</guid>
      <description>&lt;p&gt;이로써 우리는 튜토리얼을 통해 Go 언어의 특징들을 확인해볼 수 있었습니다. 사회가 복잡해지면서 개발자들은 다양한 문제들을 직면하게 되었습니다. 그 예로, 빠른 처리를 위해서 동시성(Concurrency)는 기본적으로 갖춰야하지만, 하드웨어에 부담을 덜어야하고, 프로그램 규모가 커지면 개발 속도가 상대적으로 느려지는 문제 등 현대의 프로그래밍 언어들로는 해결하기 어려운 문제들이 많았습니다.&lt;/p&gt;

&lt;p&gt;Go 언어는 이러한 문제들을 해결하기 위해 섬세하게 고안된 프로그래밍 언어입니다. 언어 자체가 기본적으로 동시성을 제공하고, 인터페이스와 덕타이핑(Duck Typing), 그리고 다양한 패키지들을 기본적으로 제공하며, 외부 패키지들의 의존성(Dependency)을 쉽게 관리할 수 있는 것처럼 개발자들의 고민을 해결해줄 수 있는 장치들이 많이 존재합니다.&lt;/p&gt;

&lt;p&gt;아래의 참고자료들을 통해 Go 언어의 매력에 대해 더 알아보고, Go 언어가 여러분들에게 의미있는 문제 해결방법이 되기를 기원합니다!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tour.golang.org&#34;&gt;A Tour of Go&lt;/a&gt; : Go언어의 문법을 전반적으로 배울 수 있는 온라인 코드랩 페이지입니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html&#34;&gt;Effective Go&lt;/a&gt; : Go언어를 효율적으로 사용하는 가이드라인을 정리한 것입니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://awesome-go.com/&#34;&gt;Awesome Go&lt;/a&gt; : Go언어를 이용해 공개된 오픈소스 프로그램들의 추천 목록입니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/groups/golangko/&#34;&gt;Golang Korea&lt;/a&gt; : Facebook 그룹 기반의 한국 Golang 커뮤니티입니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>