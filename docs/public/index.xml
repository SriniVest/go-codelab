<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go codelab step-by-step page</title>
    <link>https://mingrammer.com/go-codelab/index.xml</link>
    <description>Recent content on Go codelab step-by-step page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Nov 2016 10:20:44 +0900</lastBuildDate>
    <atom:link href="https://mingrammer.com/go-codelab/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>코드랩 소개</title>
      <link>https://mingrammer.com/go-codelab/codelab-introduction</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/codelab-introduction</guid>
      <description>

&lt;p&gt;본 코드랩은 GDG Devfest Incheon 2016에서 Google의 Open Source Language인 Go 언어에 대한 맛보기를 할 수 있도록 만들어졌습니다.
이 코드랩의 단계를 차근차근 밟아나가게 되면, 마지막에 여러분은 Go언어의 대부분의 특징(Goroutine, Channel, Interface and Method with Duck Typing, Package Import, Error Handling with Multiple Return)을 확인해볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;이번 시간엔 가상의 IoT 센서 클라이언트와 서버 간 통신에서 착안하여, 이를 Go언어를 통해 구현해보려고 합니다.&lt;/p&gt;

&lt;p&gt;순서는 다음과 같습니다.&lt;/p&gt;

&lt;h4 id=&#34;1-설치-및-환경설정-install-and-env&#34;&gt;1. &lt;a href=&#34;https://mingrammer.com/go-codelab/install-and-env&#34;&gt;설치 및 환경설정&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;2-프로젝트-구조-project-structure&#34;&gt;2. &lt;a href=&#34;https://mingrammer.com/go-codelab/project-structure&#34;&gt;프로젝트 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;3-패키지와-임포트-package-and-import&#34;&gt;3. &lt;a href=&#34;https://mingrammer.com/go-codelab/package-and-import&#34;&gt;패키지와 임포트&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;4-구조체와-인터페이스-struct-and-interface&#34;&gt;4. &lt;a href=&#34;https://mingrammer.com/go-codelab/struct-and-interface&#34;&gt;구조체와 인터페이스&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;5-클라이언트-구조-how-client-works&#34;&gt;5. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-client-works&#34;&gt;클라이언트 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;6-고루틴-채널-그리고-뮤텍스-go-routine-and-channel-and-mutex&#34;&gt;6. &lt;a href=&#34;https://mingrammer.com/go-codelab/go-routine-and-channel-and-mutex&#34;&gt;고루틴, 채널 그리고 뮤텍스&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;7-클라이언트의-동작-방식-how-client-works&#34;&gt;7. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-client-works&#34;&gt;클라이언트의 동작 방식&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;8-서버-구조-및-net-http-server-structure-and-net-http&#34;&gt;8. &lt;a href=&#34;https://mingrammer.com/go-codelab/server-structure-and-net-http&#34;&gt;서버 구조 및 net/http&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;9-서버에서-채널-동작-방식-및-로그-핸들러-how-server-and-logger-works&#34;&gt;9. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-server-and-logger-works&#34;&gt;서버에서 채널 동작 방식 및 로그 핸들러&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;10-go에서-예외-처리하기-error-handling-in-go&#34;&gt;10. &lt;a href=&#34;https://mingrammer.com/go-codelab/error-handling-in-go&#34;&gt;Go에서 예외 처리하기&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;11-애플리케이션-동작-방식-how-application-works&#34;&gt;11. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-application-works&#34;&gt;애플리케이션 동작 방식&lt;/a&gt;&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>설치 및 환경셋팅</title>
      <link>https://mingrammer.com/go-codelab/install-and-env</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/install-and-env</guid>
      <description></description>
    </item>
    
    <item>
      <title>프로젝트 구조</title>
      <link>https://mingrammer.com/go-codelab/project-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/project-structure</guid>
      <description>

&lt;h3 id=&#34;센서들의-종류&#34;&gt;센서들의 종류&lt;/h3&gt;

&lt;p&gt;본 프로젝트는 크게 3부분(Server, Sensor, Log Handler)으로 나뉠 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mingrammer.com/go-codelab/img/project_structure.png&#34; alt=&#34;Alt project_structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt;는 IoT 기기의 &lt;code&gt;Sensor&lt;/code&gt;로, 이 구조에선 Client를 의미하며, &lt;code&gt;sensor_client.go&lt;/code&gt;에서 정의되어있습니다. 이 프로젝트에서는 다음의 3개의 &lt;code&gt;Sensor&lt;/code&gt;들이 존재합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;자이로-센서-gyroscope-sensor&#34;&gt;&lt;strong&gt;자이로 센서 (Gyroscope Sensor)&lt;/strong&gt;&lt;/h4&gt;

&lt;h4 id=&#34;가속도-센서-accelometer-sensor&#34;&gt;&lt;strong&gt;가속도 센서 (Accelometer Sensor)&lt;/strong&gt;&lt;/h4&gt;

&lt;h4 id=&#34;온도-및-습도계-temperature-sensor&#34;&gt;&lt;strong&gt;온도 및 습도계 (Temperature Sensor)&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;p&gt;이들 센서의 종류는 잠시 후 설명할 &lt;code&gt;model&lt;/code&gt; 패키지에 정의되어 있으며, 센서들은 일정 시간 간격마다 &lt;code&gt;Server&lt;/code&gt;에게 &lt;code&gt;Sensor&lt;/code&gt;에서 발생한 측정값을 보내줍니다. 이 측정값으로는 각속도(Angule Velocity), 선속도(Gravitational Velocity), 온도 및 습도(Temperature and Humidity)가 있습니다.&lt;/p&gt;

&lt;p&gt;그러나, 우리는 가상의 센서를 구현하는 것이기 때문에, 실제 측정값을 넣지 못하는 관계로, &lt;code&gt;faker&lt;/code&gt;라는 것을 이용해, 가상의 난수값을 측정값으로 설정하여 서버에 보내줄 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;는 각 &lt;code&gt;Sensor&lt;/code&gt;에 대한 측정값을 HTTP Protocol을 통해서 받으며, &lt;code&gt;sensor_server.go&lt;/code&gt;에 정의되어 있습니다. 이 때, 각 측정값 종류에 대한 포트 번호는 달리해서 보내게 됩니다. &lt;code&gt;Server&lt;/code&gt;는 &lt;code&gt;Sensor&lt;/code&gt;로부터 받은 데이터의 내용으로 측정값의 종류와 그 값을 확인합니다.&lt;/p&gt;

&lt;p&gt;이렇게 확인된 데이터는 &lt;code&gt;Log Handler&lt;/code&gt;에게 넘겨지며, 이를 받은 &lt;code&gt;Log Handler&lt;/code&gt;는 실시간으로 각 &lt;code&gt;Sensor&lt;/code&gt;가 받은 측정값을 &lt;code&gt;log&lt;/code&gt; 폴더의 센서별 파일에 로그 형식으로 남깁니다.&lt;/p&gt;

&lt;p&gt;이러한 프로젝트 구조를 트리 형식으로 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go-codelab/
        faker/
                range.go
        models/
                sensor.go
        sensor_client.go
        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>패키지와 임포트</title>
      <link>https://mingrammer.com/go-codelab/package-and-import</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/package-and-import</guid>
      <description>

&lt;p&gt;이전에도 살펴봤듯이 이 튜토리얼은 다음과 같이 구성되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go-codelab/
        faker/
                range.go
        models/
                sensor.go
        sensor_client.go
        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go-codelab&lt;/code&gt;은 튜토리얼 프로젝트의 루트 디렉토리이며 모든 소스코드는 이 안에 위치합니다. &lt;code&gt;go-codelab&lt;/code&gt; 하위에는 &lt;code&gt;faker&lt;/code&gt; 디렉토리와 &lt;code&gt;models&lt;/code&gt; 디렉토리가 존재하며 &lt;code&gt;sensor_client.go&lt;/code&gt;와 &lt;code&gt;sensor_server.go&lt;/code&gt;가 단일 파일로 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;패키지&#34;&gt;패키지&lt;/h3&gt;

&lt;p&gt;Go 프로그램은 &lt;strong&gt;패키지&lt;/strong&gt;라고 하는 일련의 파일 그룹에 의해 관리됩니다. 패키지는 재사용이 가능하며 작은 단위의 &lt;code&gt;.go&lt;/code&gt; 확장자를 갖는 프로그램들로 구성됩니다. 이 튜토리얼엔 2개의 패키지가 존재합니다. 물론 정확히 말하자면 메인 패키지를 포함하여 총 3개의 패키지가 존재하지만 메인 패키지는 조금 특별하게 다뤄지므로 패키지라고 하면 메인 패키지를 제외한 일반적인 패키지를 말합니다. 이 튜토리얼엔 2개의 패키지가 존재하는데 바로 &lt;code&gt;faker&lt;/code&gt;와 &lt;code&gt;models&lt;/code&gt; 패키지입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;faker/
        range.go
models/
        sensor.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리가 다룰 패키지는 비록 단일 파일만 갖고 있지만 일반적인 경우엔 한 패키지에 작은 단위로 나뉜 여러 파일과 디렉토리가 존재합니다. 쉬운 예로 나중에 살펴보게될 &lt;code&gt;net/http&lt;/code&gt; 패키지의 경우 다음과 같이 구성되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net/http/
        cgi/
        cookiejar/
                testdata/
        fcgi/
        httptest/
        httputil/
        pprof/
        testdata/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 이제 우리 튜토리얼의 패키지들을 살펴봅시다. &lt;code&gt;faker&lt;/code&gt;의 &lt;code&gt;range.go&lt;/code&gt; 파일과 &lt;code&gt;models&lt;/code&gt;의 &lt;code&gt;sensor.go&lt;/code&gt;를 보면 상단에 다음과 같은 코드를 볼 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// faker/range.go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;math/rand&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// models/sensor.go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;models&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;strings&amp;quot;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;

	&lt;span class=&#34;s&#34;&gt;&amp;quot;github.com/mingrammer/go-codelab/faker&amp;quot;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;최상단을 보면 &lt;code&gt;package &amp;lt;name&amp;gt;&lt;/code&gt;형태의 코드를 볼 수 있습니다. 한 패키지에 속한 모든 Go 파일들은 이렇게 최상단에 자신이 속한 패키지명을 선언해야 합니다. 이 패키지명은 보통 패키지가 속한 디렉토리명을 따릅니다. 따라서, &lt;code&gt;range.go&lt;/code&gt;나 &lt;code&gt;sensor.go&lt;/code&gt;를 보면 각 파일이 &lt;code&gt;faker&lt;/code&gt;와 &lt;code&gt;models&lt;/code&gt; 패키지에 속한다는걸 바로 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;임포트&#34;&gt;임포트&lt;/h3&gt;

&lt;p&gt;위의 &lt;code&gt;range.go&lt;/code&gt;와 &lt;code&gt;sensor.go&lt;/code&gt; 파일을 보면 &lt;code&gt;package&lt;/code&gt; 아래에서 &lt;code&gt;import&lt;/code&gt;문을 볼 수 있습니다.  &lt;code&gt;import&lt;/code&gt;문을 통해 표준 또는 외부 패키지를 불러와 사용할 수 있습니다. 위 코드에서 보이는 &lt;code&gt;math/rand&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;fmt&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;는 Go의 표준 라이브러리 패키지입니다. 표준 라이브러리 패키지의 경우 해당 패키지명만 그대로 선언해주면 바로 사용할 수 있습니다. 다음은 콘솔에 값을 출력하는 코드입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 단일 import문은 이렇게 쓸 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 다중 import문은 이렇게 쓸 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그런데 &lt;code&gt;sensor.go&lt;/code&gt;의 &lt;code&gt;import&lt;/code&gt;문을 보면 &lt;code&gt;github.com/mingrammer/go-codelab/faker&lt;/code&gt;와 같이 조금 특이한 형태의 임포트문을 볼 수 있습니다. Go는 Github나 Bitbucket와 같은 곳에 호스팅 되어있는 외부 패키지와 소스코드를 패키지로써 사용할 수 있게 해줍니다. 즉, 위 임포트문은 github.com에 호스팅 되어있는 mingrammer 유저의 &lt;code&gt;go-codelab/faker&lt;/code&gt; 패키지를 사용하겠다는 의미입니다. Go에서는 표준 라이브러리가 아닌 패키지의 경우 &lt;code&gt;$GOPATH/src&lt;/code&gt;를 기준으로 패키지를 불러오기 때문에 이런 외부 패키지가 &lt;code&gt;import&lt;/code&gt;문에 선언되어 있을 때  &lt;code&gt;go get&lt;/code&gt;이라는 명령어를 사용하면 해당 위치의 패키지 구조를 &lt;code&gt;$GOPATH/src&lt;/code&gt; 하위로 다운로드 받아 해당 패키지를 사용할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;우리 프로젝트의 경우 전체 Go 프로젝트 구조는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GOPATH/
        bin/
        pkg/
        src/
                github.com/
                        mingrammer/
                                go-codelab/
                                        faker/
                                                range.go
                                        models/
                                                sensor.go
                                        sensor_client.go
                                        sensor_server.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 되면 어떤 Go 파일에서도 &lt;code&gt;github.com/mingrammer/go-codelab/&amp;lt;package name&amp;gt;&lt;/code&gt;를 &lt;code&gt;import&lt;/code&gt;에 선언하게되면 우리 프로젝트의 패키지를 사용할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;Go의 또 하나 특이한 점은 현재 사용되지 않는 패키지가 &lt;code&gt;import&lt;/code&gt;문에 선언되어 있을 경우엔 컴파일이 되지 않습니다. 즉, 미사용 패키지를 임포트하는걸 미연에 방지할 수 있습니다. 물론 &lt;code&gt;_ (blank indentifier)&lt;/code&gt;를 사용해 해당 패키지를 직접적으로 사용하지 않으면서 초기화를 위해 임포트하는 방법이 있긴 하지만 여기서는 다루지 않을 것입니다. 기본적으로 미사용 패키지의 임포트는 컴파일 에러를 발생시킨다는 것만 알아두면 됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>구조체와 인터페이스</title>
      <link>https://mingrammer.com/go-codelab/struct-and-interface</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/struct-and-interface</guid>
      <description>

&lt;p&gt;앞에서 잠깐 살펴본 모델 패키지 &lt;code&gt;models&lt;/code&gt;에는 클라이언트와 서버에서 사용할 센서들의 공용 메서드를 정의하는 &lt;code&gt;Sensor interface&lt;/code&gt;와 센서들의 공통 필드를 갖는 &lt;code&gt;SensorInfo struct&lt;/code&gt;를 정의해놓은 &lt;code&gt;sensor.go&lt;/code&gt; 파일이 있습니다.&lt;/p&gt;

&lt;p&gt;구조체와 인터페이스가 무엇인지 살펴보기 전에 실제 &lt;code&gt;sensor.go&lt;/code&gt;의 코드의 일부를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Sensor is common interface for any sensors&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// SensorInfo has common fields for any sensors&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서 보이는 &lt;code&gt;SensorInfo&lt;/code&gt;가 센서들의 공통 필드를 정의한 &lt;code&gt;struct&lt;/code&gt;이며 &lt;code&gt;Sensor&lt;/code&gt;가 센서들의 공용 메서드를 정의하는 &lt;code&gt;interface&lt;/code&gt;입니다. 그럼 이 &lt;code&gt;struct&lt;/code&gt;와 &lt;code&gt;interface&lt;/code&gt;가 무엇인지 우리 코드를 보며 자세히 살펴봅시다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;구조체-struct&#34;&gt;구조체 (Struct)&lt;/h3&gt;

&lt;p&gt;구조체 &lt;code&gt;struct&lt;/code&gt;는 여러 필드를 가질 수 있는 일종의 확장 타입입니다. C 언어에서의 &lt;code&gt;struct&lt;/code&gt;와 거의 유사합니다.&lt;code&gt;struct&lt;/code&gt;는 다음과 같이 구성됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StructName&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;embededStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;varname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;vartype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`&amp;lt;tag&amp;gt;`&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;StructName&lt;/code&gt;은 구조체의 이름을 뜻하며 &lt;code&gt;varname&lt;/code&gt;은 필드명, &lt;code&gt;vartype&lt;/code&gt;은 필드의 타입, &lt;code&gt;tag&lt;/code&gt;는 잠시후 다시 설명할 해당 필드가 인코딩 되었을 때의 키값을 정의하는 태그입니다. 참고로 Go에서는 변수를 선언할 때 &lt;code&gt;var name type&lt;/code&gt;처럼 타입을 변수명 뒤에 선언합니다. 필드의 타입은 그 어떤 타입도 가능합니다. &lt;code&gt;embededStruct&lt;/code&gt;는 조금 이따 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;우선 실제 구조체를 살펴보기 위해 &lt;code&gt;SensorInfo&lt;/code&gt; 코드를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;name&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;type&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;GenTime&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;gen_time&amp;quot;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;StructInfo&lt;/code&gt; 구조체는 &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Gentime&lt;/code&gt;이라는 필드를 가지며 각각 &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;time.Time&lt;/code&gt;의 타입을 갖습니다. 그렇다면 뒤에 &lt;code&gt;json:&amp;quot;&amp;lt;tag&amp;gt;&amp;quot;&lt;/code&gt;는 무엇일까요? 위에서 이미 말했듯이 이는 인코딩 되었을 때의 키값을 정의합니다. 즉, 이 구조체를 &lt;code&gt;JSON&lt;/code&gt; 타입으로 인코딩 했을 때 해당 필드의 키값이 &lt;code&gt;tag&lt;/code&gt;로 설정된다는 뜻입니다. 위 구조체를 &lt;code&gt;JSON&lt;/code&gt;으로 인코딩하기 되면 다음과 같이 인코딩 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &#39;name&#39;: &#39;name value&#39;,
    &#39;type&#39;: &#39;type value&#39;,
    &#39;gen_time&#39;: &#39;gentime value&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 태그는 필수는 아니며 필요에 따라 선택적으로 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 아까 언급한 &lt;code&gt;embededStruct&lt;/code&gt;를 다시 살펴봅시다. &lt;code&gt;sensor.go&lt;/code&gt;에 있는 실제 코드를 보겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// GyroSensor produces x-y-z axes angle velocity values&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityX&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;x_axis_angle_velocity&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityY&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;y_axis_angle_velocity&amp;quot;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;AngleVelocityZ&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;quot;z_axis_angle_velocity&amp;quot;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;sensor.go&lt;/code&gt;에 정의된 센서 구조체중 하나입니다. 여기에 선언되어 있는 &lt;code&gt;SensorInfo&lt;/code&gt;가 &lt;code&gt;Embedded struct&lt;/code&gt;이며 이는 &lt;code&gt;Embedding&lt;/code&gt;을 뜻합니다. 이는 다른 구조체의 정보를 그대로 가져와 사용하겠다는 뜻이며, 따라서 해당 구조체는 임베딩한 구조체의 모든 필드를 그대로 가질 수 있게됩니다. 즉, &lt;code&gt;GyroSensor&lt;/code&gt;는 &lt;code&gt;SensorInfo&lt;/code&gt;에 선언되어있는 모든 필드를 갖게됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Embedding&lt;/code&gt;을 사용하게되면 코드 중복을 피할 수 있으며, 코드의 재사용성이 증가하게 됩니다. 얼핏보면 Java, C++, Python에서의 상속과 비슷해 보이지만 다릅니다. 상속은 하위 클래스가 상위 클래스의 모든걸 가져오는 구조인 반면 &lt;code&gt;Embedding&lt;/code&gt;은 필요한 구조체의 필드들을 가져와 재사용하겠다는 의미를 가집니다. 즉, 일종의 구조체 모듈인셈입니다. Go 프로그래밍을 하게되면 앞으로 이러한 &lt;code&gt;Embedding&lt;/code&gt;을 많이 볼 수 있을 것입니다.&lt;/p&gt;

&lt;p&gt;구조체는 다음과 같이 사용할 수 있으며, 앞으로도 계속 보게될 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gyroSensor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// Embedded 구조체 필드의 경우 다음과 같이 초기화합니다.&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SensorInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;&amp;quot;GyroSensor&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;&amp;quot;VelocitySensor&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;GenTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 자체 필드는 다음과 같이 초기화합니다.&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;AngleVelocityZ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;faker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GenerateAngleVelocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;인터페이스-interface&#34;&gt;인터페이스 (Interface)&lt;/h3&gt;

&lt;p&gt;인터페이스 &lt;code&gt;interface&lt;/code&gt;는 일종의 메서드 시그니쳐의 모음입니다. Java에서의 인터페이스와 유사하며, 어떤 타입이 특정 인터페이스의 메서드들을 모두 구현하고 있으면 그 타입은 해당 인터페이스 타입을 갖게됩니다. &lt;code&gt;interface&lt;/code&gt;는 다음과 같이 구성됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;InterfaceName&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;InterfaceName&lt;/code&gt;은 인터페이스의 이름을 뜻하며, &lt;code&gt;method signature&lt;/code&gt;는 메서드의 시그니쳐입니다.&lt;/p&gt;

&lt;p&gt;실제 인터페이스를 살펴보기 위해 &lt;code&gt;Sensor&lt;/code&gt; 코드를 봅시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;SendingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ReceivingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;GenerateSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt;라는 인터페이스에 &lt;code&gt;SendingOutputString() string&lt;/code&gt;, &lt;code&gt;ReceivingOutputString string&lt;/code&gt;, &lt;code&gt;GenerateSensorData(epsilon float64) Sensor&lt;/code&gt;라는 메서드 시그니쳐들이 있습니다. 만약 어떤 타입이 이 시그니쳐들을 갖는 메서드들을 모두 구현한다면 그 타입은 &lt;code&gt;Sensor interface&lt;/code&gt; 타입을 갖게되며, &lt;code&gt;Sensor&lt;/code&gt;를 인자로 받는 그 어떤 함수의 인자로도 들어갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 실제 &lt;code&gt;GyroSensor&lt;/code&gt; 구조체에 구현된 메서드들입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SendingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ReceivingOutputString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroSensor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GenerateSensorData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epsilon&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Sensor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;GyroSensor&lt;/code&gt;는 &lt;code&gt;Sensor&lt;/code&gt; 인터페이스의 모든 메서드들을 구현하고 있으므로 &lt;code&gt;Sensor interface&lt;/code&gt; 타입이 됩니다. 즉, &lt;code&gt;Sensor&lt;/code&gt; 타입으로 사용할 수 있게 됩니다. 참고로 Go에서는 특정 타입의 메서드를 다음과 같이 선언할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// StructType 타입의 st 변수를 &amp;#39;리시버 (receiver)&amp;#39;라고 하며, 리시버를 특정 구조체 타입으로 선언하면 그 타입의 메서드가 됩니다.  &lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;st&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;returnTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// procssing with &amp;#39;st&amp;#39;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;결론적으로, 그 어떤 구조체라도 &lt;code&gt;Sensor&lt;/code&gt; 인터페이스의 세가지 메서드 시그니쳐들만 구현하면 &lt;code&gt;Sensor&lt;/code&gt;타입으로 사용할 수 있게됩니다. Go에서 인터페이스는 타입 호환성 및 확장성 측면에서 굉장히 중요한 개념으로 Go 프로그래밍을 하게되면 인터페이스를 자주 접할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;struct&lt;/code&gt;와 &lt;code&gt;interface&lt;/code&gt;를 사용해 다른 센서들처럼 호환 가능한 여러분만의 센서를 만들어보세요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>클라이언트 구조</title>
      <link>https://mingrammer.com/go-codelab/client-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/client-structure</guid>
      <description>

&lt;h3 id=&#34;클라이언트의-기본-동작-방식&#34;&gt;클라이언트의 기본 동작 방식&lt;/h3&gt;

&lt;p&gt;클라이언트가 하는 일은 간단합니다. &lt;code&gt;models&lt;/code&gt;에 정의된 센서들로부터 일정 간격으로 센서 데이터를 생성하고 이를 서버에 보내는 역할을 합니다. 기본적인 플로우는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;센서값을 서버로 보내기위한 워커를 구동하기 위한 정보를 가진 워커 정보를 정의합니다.&lt;/li&gt;
&lt;li&gt;고루틴(Goroutine)을 사용해 워커 정보의 갯수만큼 워커를 구동합니다.&lt;/li&gt;
&lt;li&gt;각 워커는 일정 간격으로 데이터를 생성해 서로 독립적으로 서버에 데이터를 전송합니다.&lt;/li&gt;
&lt;li&gt;서버 데이터 전송이 일정횟수가 넘어가면 모든 워커를 종료시켜 클라이언트 프로그램을 종료합니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>고루틴과 채널</title>
      <link>https://mingrammer.com/go-codelab/goroutine-and-channel</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/goroutine-and-channel</guid>
      <description></description>
    </item>
    
    <item>
      <title>서버 구조 및 net/http</title>
      <link>https://mingrammer.com/go-codelab/server-structure-and-net-http</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/server-structure-and-net-http</guid>
      <description>

&lt;h3 id=&#34;server-의-기본-동작-방식&#34;&gt;&lt;code&gt;Server&lt;/code&gt;의 기본 동작 방식&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;는 기본적으로 3개의 포트 번호에 대한 HTTP 서버를 생성합니다. 각 포트 번호를 달리한 것은 서로 다른 측정값 종류를 받기 위함이여, 각 번호는 다음의 의미를 갖습니다.&lt;/p&gt;

&lt;h4 id=&#34;8001번은-자이로스코프-센서의-데이터를&#34;&gt;8001번은 자이로스코프 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8002번은-가속도-센서의-데이터를&#34;&gt;8002번은 가속도 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8003번은-온도-및-습도계의-데이터를-받습니다&#34;&gt;8003번은 온도 및 습도계의 데이터를 받습니다.&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Sensor&lt;/code&gt;의 코드에서 봤듯이, HTTP 프로토콜을 이용하기 위해선 &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; 패키지가 필요합니다. &lt;code&gt;Sensor&lt;/code&gt; 클라이언트에서는 단순히 POST 요청을 보내면 되기에 패키지를 &lt;code&gt;import&lt;/code&gt;하고 필요한 API를 사용하는 것으로 끝났습니다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code&gt;net/http&lt;/code&gt; 패키지에서 서버를 생성하는 메서드인 &lt;a href=&#34;https://golang.org/pkg/net/http/#ListenAndServe&#34;&gt;&lt;code&gt;ListenAndServe()&lt;/code&gt;&lt;/a&gt; 메서드를 확인해보면, 인자로 &lt;a href=&#34;https://golang.org/pkg/net/http/#Handler&#34;&gt;&lt;code&gt;Handler Interface&lt;/code&gt;&lt;/a&gt;를 요구하고 있습니다. 이 &lt;code&gt;Handler Interface&lt;/code&gt;를 다시 확인해보면, 결국 &lt;a href=&#34;https://golang.org/pkg/net/http/#HandlerFunc&#34;&gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;라는 메서드를 요구합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;handler-interface-구현하기&#34;&gt;&lt;code&gt;Handler Interface&lt;/code&gt; 구현하기&lt;/h3&gt;

&lt;p&gt;따라서, 우리는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드가 구현된 &lt;code&gt;Handler Interface&lt;/code&gt;가 필요합니다. 이를 위해, 우리는 각 데이터 종류에 대한 &lt;code&gt;Interface&lt;/code&gt;를 다음과 같이 만들어줘야 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 핸들러를 만들어주고, 이 핸들러들이 쓸 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 구현해야합니다. 앞에서 우리가 구조체와 인터페이스에 대해 배웠을 때, 다음과 같은 코드를 봤습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;st&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;returnTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// procssing with &amp;#39;st&amp;#39;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;특정 메서드를 특정 구조체에 연결하기 위해 &lt;code&gt;Pointer Receiver&lt;/code&gt;를 사용했습니다. 우리의 경우, &lt;code&gt;main()&lt;/code&gt; 메서드에서 만들었던 &lt;code&gt;Handler Instance&lt;/code&gt;를 생성했기 때문에 이 핸들러 인스턴스에서 사용할 수 있는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 구현해줘야합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 온도계 및 습도계에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 자이로 센서에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 가속도 센서에서 받은 데이터를 처리합니다.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 다음 페이지에선&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;도전&#34;&gt;도전&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;구조체와 인터페이스&lt;/code&gt; 단계에서 만들었던 여러분들만의 센서에 대해 &lt;code&gt;Handler Interface&lt;/code&gt;와 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드를 정의해보세요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>서버에서의 채널 동작 방식 및 로그 핸들러</title>
      <link>https://mingrammer.com/go-codelab/how-server-and-logger-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-server-and-logger-works</guid>
      <description>

&lt;h3 id=&#34;data-pipeline으로서-channel&#34;&gt;Data Pipeline으로서 Channel&lt;/h3&gt;

&lt;p&gt;이렇게 &lt;code&gt;Server&lt;/code&gt;는 HTTP Protocol을 통해 받은 데이터를 로그 파일에 남길 형식으로 가공하여 &lt;code&gt;Log Handler&lt;/code&gt;에게 전달해줍니다. 여기서 &lt;code&gt;Log Handler&lt;/code&gt;는 sensor_server.go에서 함수로 구현되어 현재 Goroutine 상에서 실행되고 있습니다. 그렇다면 각 HTTP 핸들러는 &lt;code&gt;Log Handler&lt;/code&gt;인 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드에게 데이터를 어떻게 보내야할까요? 여기서 사용되는 것이 Channel입니다.&lt;/p&gt;

&lt;p&gt;sensor_server.go 내에서 로그컨텐트에 대한 채널을 만들어줍니다. 그리고 이 채널을 &lt;code&gt;ServeHTTP()&lt;/code&gt;를 구현한 각 핸들러 구조체를 생성할 때 인자로 같이 넘겨줍니다. 이렇게 되면 각 구조체는 해당 채널에 대한 사용권을 받게 됩니다. 마찬가지로, 로그를 남기는 역할을 하는 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드도 채널 사용권을 인자로 넘겨받습니다. 이렇게 되면 데이터를 보내야할 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드와 데이터를 받아야할 &lt;code&gt;Log Handler&lt;/code&gt;가 채널을 통해 데이터를 교환할 수 있는 환경이 만들어졌습니다!&lt;/p&gt;

&lt;h3 id=&#34;양방향-채널-단방향-채널&#34;&gt;양방향 채널? 단방향 채널!&lt;/h3&gt;

&lt;p&gt;기본적으로 채널을 생성하게 되면 채널은 양방향의 성격을 가지게 됩니다. 다시 말해, 채널은 특별한 언급이 없으면 어디서든 데이터를 저장하고, 불러올 수 있도록 전제하고 있습니다. 이해가 잘 안 간다고요? 그럼 예시로 설명해보죠.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ShowMeTheChannel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;채널을 이용한 간단한 메서드를 만들어 봤습니다. &lt;code&gt;data&lt;/code&gt;라는 채널은 int형 파이프라인으로 선언되었습니다. 그리고 &lt;code&gt;ShowMeTheChannel()&lt;/code&gt;이라는 메서드는 반복문 10번씩 두 번 돌면서 각각 데이터를 저장하고, 불러옵니다. 이 메서드는 채널의 양 끝에 대한 사용권을 모두 가지고 있죠. 이것을 우리는 양방향 채널(Bidirectional Channel)이라고 합니다.&lt;/p&gt;

&lt;p&gt;여려분이 만들 프로그램은 각 데이터 종류에 대한 핸들러와 &lt;code&gt;fileLogger()&lt;/code&gt;메서드가 채널을 사용합니다. 만약 각 요소에서 데이터를 활용할 방향성에 대해 정의하지 않으면, 자신의 권한과 상관없이 데이터를 마음껏 저장하고 불러올 수 있겠죠. 이건 우리가 이상적으로 생각하는 모습이 아닙니다. 그래서 우리는 각 핸들러와 메서드가 사용할 채널의 방향성을 지정해줌으로서 파이프라인에서의 데이터의 흐름을 한 방향으로 보장하도록 하려고 합니다. 고맙게도 고언어에서는 이에 대해서도 미리 &lt;a href=&#34;https://golang.org/ref/spec#Channel_types&#34;&gt;준비&lt;/a&gt;를 해놨습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 사용권을 받으면 채널에서 T 타입 데이터를 불러오고 저장할 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float64&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 받게 되면 채널에서 T 타입 데이터를 불러오기만 할 수 있습니다.&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 이런 형식으로 받으면 T 타입 데이터를 채널에 저장만 할 수 있습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그렇다면 우리는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드에선 채널에서 데이터를 보내기만 하도록, &lt;code&gt;fileLogger()&lt;/code&gt; 메서드에선 채널에서 데이터를 받기만 하도록 지정해줘야겠죠. 따라서 우리는 각 메서드의 정의에서 채널의 방향성을 아래와 같이 지정해줘야합니다. 이렇게 바꿔주면 에러가 날까봐 걱정인가요? 지금까지 잘 따라왔다면 에러없이 잘 작동할 것입니다. :)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;로그-로그를-보자&#34;&gt;로그, 로그를 보자!&lt;/h3&gt;

&lt;p&gt;이제 로그를 남겨봅시다! 로그는 각 센서별로 정보를 모아서 저장을 할 것입니다. 이미 눈치 채신 분들이 있겠지만, 이미 프로젝트 폴더에 로그라는 폴더가 존재합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log/
		Accel.log
		Gyro.log
		Temp.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;약어가 의미하듯이 엑셀.로그는 가속도 센서의 측정값을, 자이로.로그는 자이로 센서의 측정값을, 그리고 템프.로그는 온도 및 습도계의 측정값을 저장합니다. 로그를 본격적으로 저장하기 전에, 우리가 로그를 저장할 폴더가 존재하는지 확인해야합니다. 이를 외해 &lt;a href=&#34;https://golang.org/pkg/os/#Open&#34;&gt;&lt;code&gt;os.Open(&#39;log&#39;)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 사용할 것입니다.만약 이 메서드가 로그 폴더를 정상적으로 찾아내면, 그에 대한 파일 타입을 반환할 것입니다. 아닐 경우, 로그 폴더를 &lt;a href=&#34;https://golang.org/pkg/os/#Mkdir&#34;&gt;&lt;code&gt;os.Mkdir(&#39;log&#39;, os.ModePerm)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 이용해 생성할 것입니다.&lt;/p&gt;

&lt;p&gt;로그 폴더가 정상적으로 존재하는 경우, &lt;code&gt;Log Handler&lt;/code&gt;인 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드는 채널에 값이 들어오기를 기다립니다. 아래의 &lt;code&gt;for := range&lt;/code&gt; 문구가 그 역할을 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for logData := range logStream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;for, range&lt;/code&gt; 문은 main 메서드에서 전달받은 채널에 데이터가 존재할지 기다리고, 존재하는 경우 바로 내부 코드를 실행합니다. 이런 과정은 프로그램이 강제로 종료하거나, 외부에서 채널을 종료(Close)하기까지 계속 반복됩니다.&lt;/p&gt;

&lt;p&gt;채널에 데이터가 들어오게 되면 받은 데이터 구조체에서 해당 데이터가 저장될 위치를 읽어와 이를 디렉토리 주소로 조합하고 해당 로그파일을 열게됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;joinee&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logDir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;joinee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OpenFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_CREATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_WRONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;O_APPEND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0666&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;해당 파일이 정상적으로 열릴 경우, 다음 단계로 넘어가면 됩니다. (만약 에러가 발생하면 이에 대한 예외처리가 필요합니다.) 이제 파일에 로그를 남겨줄 &lt;code&gt;logger&lt;/code&gt;를 만들겁니다. 여기서 우리는 &lt;a href=&#34;https://golang.org/pkg/log&#34;&gt;log 패키지&lt;/a&gt;를 이용해 직접 해당 파일로 로그를 남기는 로거를 직접 만들어보겠습니다. 아래의 &lt;a href=&#34;https://golang.org/pkg/log/#New&#34;&gt;New()&lt;/a&gt; 메서드는 특정 &lt;code&gt;Writer&lt;/code&gt; 인터페이스로 로그를 남길 수 있도록 합니다. 여러분의 경우, 파일에 로그를 남기기로 했으니, 위에서 열어준 &lt;code&gt;fileHandle&lt;/code&gt;을 이용하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fileHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LstdFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;[%s Data Received]\n%s\n&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sensorName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이렇게 생성한 &lt;code&gt;logger&lt;/code&gt;를 이용해 로그 내용을 출력하게 되면 다음과 같은 결과를 로그파일에서 확인할 수 있습니다. 결과값은 &lt;code&gt;main()&lt;/code&gt; 메서드에서 실제로 핸들러와 로거를 실행해서 결과를 확인해봅시다!&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;일해라-서버야&#34;&gt;일해라 서버야!&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;main()&lt;/code&gt; 메서드에서 우리가 정의해줬던 것들을 실제로 실행할 수 있게 해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, HTTP 핸들러 메서드에서 로그 핸들러로 기록할 로그의 내용을 전달해주는 채널, 각 센서에 대한 핸들러를 정의해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;gyroHander&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GyroHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;accelHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AccelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;tempHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그 다음엔 실제 HTTP 서버를 실행하는 &lt;code&gt;ListenAndServe()&lt;/code&gt; 메서드를 실행합니다. 여기서 주의할 것은, 그냥 실행하면 맨 위의 한 개 서버만 생성이 됩니다. &lt;code&gt;ListenAndServe()&lt;/code&gt; 메서드가 실행되면 그 즉시 해당 핸들러에 대해 HTTP 요청을 대기 시작하기 때문입니다. 우리는 3개의 센서에 대한 서버가 동시에 돌아가는 것을 윈하는 것이죠? 이 때 고루틴을 적용해줍니다! 단순히 실행할 메서드 앞에 &lt;code&gt;go&lt;/code&gt;를 붙여주면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8001&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gyroHander&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8002&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;accelHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;:8003&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tempHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그리고 동시에 파일로거도 실행이 되어야겠죠? &lt;code&gt;fileLogger()&lt;/code&gt; 메서드도 고루틴을 이용해 실행해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 바로 실행을 해볼까요? 실행이 잘 되나요? 아마 안 될 겁니다. 왜냐하면 고루틴들이 일을 하고 있지만, 프로그램 메인 프로세스가 먼저 종료되었기 때문입니다. 기본적으로 고루틴들이 종료되기를 기다리지 않는다는 것이죠. 그래서 우리는 메인 스레드가 고루틴을 기다릴 수 있도록 한 가지를 더 추가할 것입니다. 바로 &lt;a href=&#34;https://golang.org/pkg/sync/#WaitGroup&#34;&gt;&lt;code&gt;WaitGroup&lt;/code&gt;&lt;/a&gt;입니다. 이 &lt;code&gt;WaitGroup&lt;/code&gt;에서 우리는 &lt;code&gt;Wait()&lt;/code&gt;이라는 메서드를 사용해서 고루틴들이 끝나기기 까지 기다려야하지만, 그 전에 얼마나 많은 고루틴을 기다려야하는지를 정의해야합니다. 이 때 우리는 &lt;code&gt;Add()&lt;/code&gt; 메서드를 이용하며, 얼마나 더 많은 고루틴을 기다릴지 &lt;code&gt;WaitGroup&lt;/code&gt;에 알려줍니다. 우리의 경우 4개의 고루틴을 기다려야겠죠? (주의할 것은 &lt;code&gt;WaitGroup&lt;/code&gt;은 &lt;code&gt;sync&lt;/code&gt; 패키지에 정의되어 있는 타입이기 때문에 이 또한 &lt;code&gt;import&lt;/code&gt;해줘야 합니다!!)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;quot;sync&amp;quot;&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그리고 고루틴들을 실행하고 기다려주도록 &lt;code&gt;Wait()&lt;/code&gt; 메서드를 실행해줍니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code&gt;WaitGroup&lt;/code&gt;까지 만들어줬으면 프로그램을 실행해봅니다! 만약 정상적으로 프로그램이 실행된다면 로그 파일에 다음과 같이 표시 될 것 입니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/11/12 17:03:06 [GyroSensor Data Received]
Measured on 2016-11-12 17:03:06.032046895 +0900 KST
Angle Velocity of X-axis : 12.025082
Angle Velocity of Y-axis : 182.022138
Angle Velocity of Z-axis : 122.692864
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>에러 핸들링</title>
      <link>https://mingrammer.com/go-codelab/error-handling-in-go</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/error-handling-in-go</guid>
      <description></description>
    </item>
    
    <item>
      <title>애플리케이션 동작 과정</title>
      <link>https://mingrammer.com/go-codelab/how-application-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-application-works</guid>
      <description></description>
    </item>
    
  </channel>
</rss>