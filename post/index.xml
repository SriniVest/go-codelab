<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Go codelab step-by-step page</title>
    <link>https://mingrammer.com/go-codelab/post/index.xml</link>
    <description>Recent content in Posts on Go codelab step-by-step page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Nov 2016 10:20:44 +0900</lastBuildDate>
    <atom:link href="https://mingrammer.com/go-codelab/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>코드랩 소개</title>
      <link>https://mingrammer.com/go-codelab/codelab-introduction</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/codelab-introduction</guid>
      <description>

&lt;p&gt;본 코드랩은 GDG Devfest Incheon 2016에서 Google의 Open Source Language인 Go 언어에 대한 맛보기를 할 수 있도록 만들어졌습니다.
이 코드랩의 단계를 차근차근 밟아나가게 되면, 마지막에 여러분은 Go언어의 대부분의 특징(Goroutine, Channel, Interface and Method with Duck Typing, Package Import, Error Handling with Multiple Return)을 확인해볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;이번 시간엔 가상의 IoT 센서 클라이언트와 서버 간 통신에서 착안하여, 이를 Go언어를 통해 구현해보려고 합니다.&lt;/p&gt;

&lt;p&gt;순서는 다음과 같습니다.&lt;/p&gt;

&lt;h4 id=&#34;1-설치-및-환경설정-install-and-env&#34;&gt;1. &lt;a href=&#34;https://mingrammer.com/go-codelab/install-and-env&#34;&gt;설치 및 환경설정&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;2-프로젝트-구조-project-structure&#34;&gt;2. &lt;a href=&#34;https://mingrammer.com/go-codelab/project-structure&#34;&gt;프로젝트 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;3-모델-및-모델-패키지-models&#34;&gt;3. &lt;a href=&#34;https://mingrammer.com/go-codelab/models&#34;&gt;모델 및 모델 패키지&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;4-struct와-interface-struct-and-interface&#34;&gt;4. &lt;a href=&#34;https://mingrammer.com/go-codelab/struct-and-interface&#34;&gt;Struct와 Interface&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;5-interface-method-구현-implement-interface-method&#34;&gt;5. &lt;a href=&#34;https://mingrammer.com/go-codelab/implement-interface-method&#34;&gt;Interface Method 구현&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;6-클라이언트의-구조-및-main-package-how-client-works&#34;&gt;6. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-client-works&#34;&gt;클라이언트의 구조 및 main package&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;7-클라이언트에서-goroutine-channel-mutex-활용-방식-go-routine-and-channel-and-mutex&#34;&gt;7. &lt;a href=&#34;https://mingrammer.com/go-codelab/go-routine-and-channel-and-mutex&#34;&gt;클라이언트에서 Goroutine, Channel, Mutex 활용 방식&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;8-클라이언트의-작동-방식-how-client-works&#34;&gt;8. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-client-works&#34;&gt;클라이언트의 작동 방식&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;9-faker의-구조-faker-structure&#34;&gt;9. &lt;a href=&#34;https://mingrammer.com/go-codelab/faker-structure&#34;&gt;Faker의 구조&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;10-서버의-구조-net-http-패키지를-활용한-포트별-개별서버-구동-server-structure-and-net-http&#34;&gt;10. &lt;a href=&#34;https://mingrammer.com/go-codelab/server-structure-and-net-http&#34;&gt;서버의 구조 (net/http 패키지를 활용한 포트별 개별서버 구동)&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;11-서버에서-channel-활용-방식-및-log-handler-how-server-and-logger-works&#34;&gt;11. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-server-and-logger-works&#34;&gt;서버에서 Channel 활용 방식 및 Log Handler&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;12-go에서-예외-처리하기-error-handling-in-go&#34;&gt;12. &lt;a href=&#34;https://mingrammer.com/go-codelab/error-handling-in-go&#34;&gt;Go에서 예외 처리하기&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&#34;13-큰-그림-다시-보기-how-application-works&#34;&gt;13. &lt;a href=&#34;https://mingrammer.com/go-codelab/how-application-works&#34;&gt;큰 그림 다시 보기&lt;/a&gt;&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>설치 및 환경셋팅</title>
      <link>https://mingrammer.com/go-codelab/install-and-env</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/install-and-env</guid>
      <description></description>
    </item>
    
    <item>
      <title>프로젝트 구조</title>
      <link>https://mingrammer.com/go-codelab/project-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/project-structure</guid>
      <description>

&lt;h3 id=&#34;센서들의-종류&#34;&gt;센서들의 종류&lt;/h3&gt;

&lt;p&gt;본 프로젝트는 크게 3부분(Server, Sensor, Log Handler)으로 나뉠 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mingrammer.com/go-codelab/img/project_structure.png&#34; alt=&#34;Alt project_structure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;는 IoT 기기의 &lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;로, 이 구조에선 Client를 의미하며, &lt;code&gt;sensor_client.go&lt;/code&gt;에서 정의되어있습니다. 이 프로젝트에서는 다음의 3개의 &lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;들이 존재합니다.2&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;자이로-센서-gyroscope-sensor&#34;&gt;&lt;strong&gt;자이로 센서 (Gyroscope Sensor)&lt;/strong&gt;&lt;/h4&gt;

&lt;h4 id=&#34;가속도-센서-accelometer-sensor&#34;&gt;&lt;strong&gt;가속도 센서 (Accelometer Sensor)&lt;/strong&gt;&lt;/h4&gt;

&lt;h4 id=&#34;온도-및-습도계-temperature-sensor&#34;&gt;&lt;strong&gt;온도 및 습도계 (Temperature Sensor)&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;p&gt;이들 센서의 종류는 잠시 후 설명할 &lt;code&gt;model&lt;/code&gt; 패키지에 정의되어 있으며, 센서들은 일정 시간 간격마다 &lt;em&gt;&lt;code&gt;Server&lt;/code&gt;&lt;/em&gt;에게 &lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;에서 발생한 측정값을 보내줍니다. 이 측정값으로는 각속도(&lt;code&gt;Angule Velocity&lt;/code&gt;), 선속도(&lt;code&gt;Gravitational Velocity&lt;/code&gt;), 온도 및 습도(&lt;code&gt;Temperature and Humidity&lt;/code&gt;)가 있습니다.&lt;/p&gt;

&lt;p&gt;그러나, 우리는 가상의 센서를 구현하는 것이기 때문에, 실제 측정값을 넣지 못하는 관계로, &lt;code&gt;faker&lt;/code&gt;라는 것을 이용해, 가상의 난수값을 측정값으로 설정하여 서버에 보내줄 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;Server&lt;/code&gt;&lt;/em&gt;는 각 &lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;에 대한 측정값을 HTTP Protocol을 통해서 받으며, &lt;code&gt;sensor_server.go&lt;/code&gt;에 정의되어 있습니다. 이 때, 각 측정값 종류에 대한 포트 번호는 달리해서 보내게 됩니다. &lt;code&gt;&amp;lt;em&amp;gt;Server&lt;/code&gt;&lt;/em&gt;는 &lt;code&gt;&amp;lt;em&amp;gt;Sensor&lt;/code&gt;&lt;/em&gt;로부터 받은 데이터의 내용으로 측정값의 종류와 그 값을 확인합니다.&lt;/p&gt;

&lt;p&gt;이렇게 확인된 데이터는 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;에게 넘겨지며, 이를 받은 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;는 실시간으로 각 &lt;em&gt;&lt;code&gt;Sensor&lt;/code&gt;&lt;/em&gt;가 받은 측정값을 &lt;code&gt;log&lt;/code&gt; 폴더의 센서별 파일에 로그 형식으로 남깁니다.&lt;/p&gt;

&lt;p&gt;이러한 프로젝트 구조를 트리 형식으로 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── faker
│   └── range.go
├── log
│   ├── Accel.log
│   ├── Gyro.log
│   └── Temp.log
├── models
│   └── sensor.go
├── README.md
├── sensor_client.go
└── sensor_server.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>모델과 패키지</title>
      <link>https://mingrammer.com/go-codelab/models</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/models</guid>
      <description></description>
    </item>
    
    <item>
      <title>Struct와 Interface</title>
      <link>https://mingrammer.com/go-codelab/struct-and-interface</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/struct-and-interface</guid>
      <description></description>
    </item>
    
    <item>
      <title>인터페이스 메서드</title>
      <link>https://mingrammer.com/go-codelab/implement-interface-methods</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/implement-interface-methods</guid>
      <description></description>
    </item>
    
    <item>
      <title>클라이언트 구조</title>
      <link>https://mingrammer.com/go-codelab/client-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/client-structure</guid>
      <description></description>
    </item>
    
    <item>
      <title>고루틴, 채널 그리고 뮤텍스</title>
      <link>https://mingrammer.com/go-codelab/go-routine-and-channel-and-mutex</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/go-routine-and-channel-and-mutex</guid>
      <description></description>
    </item>
    
    <item>
      <title>클라이언트 동작 방식</title>
      <link>https://mingrammer.com/go-codelab/how-client-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-client-works</guid>
      <description></description>
    </item>
    
    <item>
      <title>Faker 구조</title>
      <link>https://mingrammer.com/go-codelab/faker-structure</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/faker-structure</guid>
      <description></description>
    </item>
    
    <item>
      <title>서버 구조 및 net/http</title>
      <link>https://mingrammer.com/go-codelab/server-structure-and-net-http</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/server-structure-and-net-http</guid>
      <description>

&lt;h3 id=&#34;서버의-기본-동작-방식&#34;&gt;서버의 기본 동작 방식&lt;/h3&gt;

&lt;p&gt;서버는 기본적으로 3개의 포트 번호에 대한 HTTP Server를 생성합니다. 각 포트 번호를 달리한 것은 서로 다른 측정값 종류를 받기 위함이여, 각 번호는 다음의 의미를 갖습니다.&lt;/p&gt;

&lt;h4 id=&#34;8001번은-자이로스코프-센서의-데이터를&#34;&gt;8001번은 자이로스코프 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8002번은-가속도-센서의-데이터를&#34;&gt;8002번은 가속도 센서의 데이터를,&lt;/h4&gt;

&lt;h4 id=&#34;8003번은-온도-및-습도계의-데이터를-받습니다&#34;&gt;8003번은 온도 및 습도계의 데이터를 받습니다.&lt;/h4&gt;

&lt;p&gt;센서의 코드에서 봤듯이, HTTP 프로토콜을 이용하기 위해선 &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; 패키지가 필요합니다. 센서 클라이언트에서는 단순히 POST 요청을 보내면 됐기에 패키지를 &lt;code&gt;import&lt;/code&gt;하고 추가작업이 필요하지 않았습니다.&lt;/p&gt;

&lt;p&gt;그러나, &lt;code&gt;net/http&lt;/code&gt; 패키지에서 서버를 생성하는 메서드인 &lt;a href=&#34;https://golang.org/pkg/net/http/#ListenAndServe&#34;&gt;&lt;code&gt;ListenAndServe()&lt;/code&gt;&lt;/a&gt; 메서드를 확인해보면, 인자로 &lt;a href=&#34;https://golang.org/pkg/net/http/#Handler&#34;&gt;핸들러 인터페이스&lt;/a&gt;를 요구하고 있습니다. 이 핸들러 인터페이스를 다시 확인해보면, 결국 &lt;a href=&#34;https://golang.org/pkg/net/http/#HandlerFunc&#34;&gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;라는 메서드를 요구합니다.&lt;/p&gt;

&lt;p&gt;따라서, 우리는 ServeHTTP() 메서드가 구현된 핸들러 인터페이스가 필요합니다. 이를 위해, 우리는 각 데이터 종류에 대한 인터페이스를 다음과 같이 만들어줘야 합니다.&lt;/p&gt;
// GyroHandler : Gyroscopte sensor handler to implement ServeHTTP method
type GyroHandler struct {

}

// AccelHandler : Accelerator sensro handler to implement ServeHTTP method
type AccelHandler struct {

}

// TempHandler 	: Temperature sensor handler to implement ServeHTTP method
type TempHandler struct {

}
</description>
    </item>
    
    <item>
      <title>서버에서의 채널 동작 방식 및 로그 핸들러</title>
      <link>https://mingrammer.com/go-codelab/how-server-and-logger-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-server-and-logger-works</guid>
      <description>

&lt;h3 id=&#34;data-pipeline으로서-channel&#34;&gt;Data Pipeline으로서 Channel&lt;/h3&gt;

&lt;p&gt;이렇게 &lt;em&gt;&lt;code&gt;Server&lt;/code&gt;&lt;/em&gt;는 HTTP Protocol을 통해 받은 데이터를 로그 파일에 남길 형식으로 가공하여 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;에게 전달해줍니다. 여기서 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;는 sensor_server.go에서 함수로 구현되어 현재 Goroutine 상에서 실행되고 있습니다. 그렇다면 각 HTTP 핸들러는 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;인 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드에게 데이터를 어떻게 보내야할까요? 여기서 사용되는 것이 Channel입니다.&lt;/p&gt;

&lt;p&gt;sensor_server.go 내에서 로그컨텐트에 대한 채널을 만들어줍니다. 그리고 이 채널을 &lt;code&gt;ServeHTTP()&lt;/code&gt;를 구현한 각 핸들러 구조체를 생성할 때 인자로 같이 넘겨줍니다. 이렇게 되면 각 구조체는 해당 채널에 대한 사용권을 받게 됩니다. 마찬가지로, 로그를 남기는 역할을 하는 &lt;code&gt;fileLogger()&lt;/code&gt; 메서드도 채널 사용권을 인자로 넘겨받습니다. 이렇게 되면 데이터를 보내야할 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드와 데이터를 받아야할 &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;가 채널을 통해 데이터를 교환할 수 있는 환경이 만들어졌습니다!&lt;/p&gt;

&lt;h3 id=&#34;양방향-채널-단방향-채널&#34;&gt;양방향 채널? 단방향 채널!&lt;/h3&gt;

&lt;p&gt;기본적으로 채널을 생성하게 되면 채널은 양방향의 성격을 가지게 됩니다. 다시 말해, 채널은 특별한 언급이 없으면 어디서든 데이터를 저장하고, 불러올 수 있도록 전제하고 있습니다. 이해가 잘 안 간다고요? 그럼 예시로 설명해보죠.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ShowMeTheChannel() {
	data := make(chan int)

	for i := 0; i &amp;lt; 10; i++ {
		data &amp;lt;- i
	}

	for i := 0; i &amp;lt; 10; i ++ {
		fmt.Println(&amp;lt;-data)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;채널을 이용한 간단한 메서드를 만들어 봤습니다. &lt;code&gt;data&lt;/code&gt;라는 채널은 int형 파이프라인으로 선언되었습니다. 그리고 &lt;code&gt;ShowMeTheChannel()&lt;/code&gt;이라는 메서드는 반복문 10번씩 두 번 돌면서 각각 데이터를 저장하고, 불러옵니다. 이 메서드는 채널의 양 끝에 대한 사용권을 모두 가지고 있죠. 이것을 우리는 양방향 채널(Bidirectional Channel)이라고 합니다.&lt;/p&gt;

&lt;p&gt;여려분이 만들 프로그램은 각 데이터 종류에 대한 핸들러와 &lt;code&gt;fileLogger()&lt;/code&gt;메서드가 채널을 사용합니다. 만약 각 요소에서 데이터를 활용할 방향성에 대해 정의하지 않으면, 자신의 권한과 상관없이 데이터를 마음껏 저장하고 불러올 수 있겠죠. 이건 우리가 이상적으로 생각하는 모습이 아닙니다. 그래서 우리는 각 핸들러와 메서드가 사용할 채널의 방향성을 지정해줌으로서 파이프라인에서의 데이터의 흐름을 한 방향으로 보장하도록 하려고 합니다. 고맙게도 고언어에서는 이에 대해서도 미리 &lt;a href=&#34;https://golang.org/ref/spec#Channel_types&#34;&gt;준비&lt;/a&gt;를 해놨습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chan T          // 이런 형식으로 사용권을 받으면 채널에서 T 타입 데이터를 불러오고 저장할 수 있습니다.
chan&amp;lt;- float64  // 이런 형식으로 받게 되면 채널에서 T 타입 데이터를 불러오기만 할 수 있습니다.
&amp;lt;-chan int      // 이런 형식으로 받으면 T 타입 데이터를 채널에 저장만 할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇다면 우리는 &lt;code&gt;ServeHTTP()&lt;/code&gt; 메서드에선 채널에서 데이터를 보내기만 하도록, &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt; 메서드에선 채널에서 데이터를 받기만 하도록 지정해줘야겠죠. 따라서 우리는 각 메서드의 정의에서 채널의 방향성을 아래와 같이 지정해줘야합니다. 이렇게 바꿔주면 에러가 날까봐 걱정인가요? 지금까지 잘 따라왔다면 에러없이 잘 작동할 것입니다. :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type GyroHandler struct {
	buf chan&amp;lt;- logContent
}

type AccelHandler struct {
	buf chan&amp;lt;- logContent
}

type TempHandler struct {
	buf chan&amp;lt;- logContent
}

func fileLogger(logStream &amp;lt;-chan logContent) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;로그-로그를-보자&#34;&gt;로그, 로그를 보자!&lt;/h3&gt;

&lt;p&gt;이제 로그를 남겨봅시다! 로그는 각 센서별로 정보를 모아서 저장을 할 것입니다. 이미 눈치 채신 분들이 있겠지만, 이미 프로젝트 폴더에 로그라는 폴더가 존재합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── log
│   ├── Accel.log
│   ├── Gyro.log
│   └── Temp.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;약어가 의미하듯이 엑셀.로그는 가속도 센서의 측정값을, 자이로.로그는 자이로 센서의 측정값을, 그리고 템프.로그는 온도 및 습도계의 측정값을 저장합니다. 로그를 본격적으로 저장하기 전에, 우리가 로그를 저장할 폴더가 존재하는지 확인해야합니다. 이를 외해 &lt;a href=&#34;https://golang.org/pkg/os/#Open&#34;&gt;&lt;code&gt;os.Open(&#39;log&#39;)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 사용할 것입니다.만약 이 메서드가 로그 폴더를 정상적으로 찾아내면, 그에 대한 파일 타입을 반환할 것입니다. 아닐 경우, 로그 폴더를 &lt;a href=&#34;https://golang.org/pkg/os/#Mkdir&#34;&gt;&lt;code&gt;os.Mkdir(&#39;log&#39;, os.ModePerm)&lt;/code&gt;&lt;/a&gt;이라는 메서드를 이용해 생성할 것입니다.&lt;/p&gt;

&lt;p&gt;로그 폴더가 정상적으로 존재하는 경우, &lt;em&gt;&lt;code&gt;Log Handler&lt;/code&gt;&lt;/em&gt;인 fileLogger()&lt;code&gt;메서드는 채널에 값이 들어오기를 기다립니다. 아래의&lt;/code&gt;for, range` 문구가 그 역할을 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for logData := range logStream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;for, range&lt;/code&gt; 문은 main 메서드에서 전달받은 채널에 데이터가 존재할지 기다리고, 존재하는 경우 바로 내부 코드를 실행합니다. 이런 과정은 프로그램이 강제로 종료하거나, 외부에서 채널을 종료(Close)하기까지 계속 반복됩니다.&lt;/p&gt;

&lt;p&gt;채널에 데이터가 들어오게 되면 받은 데이터 구조체에서 해당 데이터가 저장될 위치를 읽어와 이를 디렉토리 주소로 조합하고 해당 로그파일을 열게됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;joinee := []string{logDir, logData.location}
filePath := strings.Join(joinee, &amp;quot;/&amp;quot;)

fileHandle, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해당 파일이 정상적으로 열릴 경우, 다음 단계로 넘어가면 됩니다. (만약 에러가 발생하면 이에 대한 예외처리가 필요합니다.) 이제 파일에 로그를 남겨줄 &lt;code&gt;logger&lt;/code&gt;를 만들겁니다. 여기서 우리는 &lt;a href=&#34;https://golang.org/pkg/log&#34;&gt;log 패키지&lt;/a&gt;를 이용해 직접 해당 파일로 로그를 남기는 로거를 직접 만들어보겠습니다. 아래의 &lt;a href=&#34;https://golang.org/pkg/log/#New&#34;&gt;New()&lt;/a&gt; 메서드는 특정 &lt;code&gt;Writer&lt;/code&gt; 인터페이스로 로그를 남길 수 있도록 합니다. 여러분의 경우, 파일에 로그를 남기기로 했으니, 위에서 열어준 &lt;code&gt;fileHandle&lt;/code&gt;을 이용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logger := log.New(fileHandle, &amp;quot;&amp;quot;, log.LstdFlags)
logger.Printf(&amp;quot;[%s Data Received]\n%s\n&amp;quot;, logData.sensorName, logData.content)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 생성한 &lt;code&gt;logger&lt;/code&gt;를 이용해 로그 내용을 출력하게 되면 다음과 같은 결과를 로그파일에서 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/11/12 17:03:06 [GyroSensor Data Received]
Measured on 2016-11-12 17:03:06.032046895 +0900 KST
Angle Velocity of X-axis : 12.025082
Angle Velocity of Y-axis : 182.022138
Angle Velocity of Z-axis : 122.692864
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>에러 핸들링</title>
      <link>https://mingrammer.com/go-codelab/error-handling-in-go</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/error-handling-in-go</guid>
      <description></description>
    </item>
    
    <item>
      <title>애플리케이션 동작 과정</title>
      <link>https://mingrammer.com/go-codelab/how-application-works</link>
      <pubDate>Mon, 14 Nov 2016 10:20:44 +0900</pubDate>
      
      <guid>https://mingrammer.com/go-codelab/how-application-works</guid>
      <description></description>
    </item>
    
  </channel>
</rss>